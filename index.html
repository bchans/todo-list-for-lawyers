<!DOCTYPE html>
<!-- 
================================================================================
OFFLINE-FIRST APPLICATION - CRITICAL DESIGN REQUIREMENTS
================================================================================
This application MUST remain fully functional offline after initial load.

KEY REQUIREMENTS FOR ALL FUTURE CHANGES:
1. ALL user data (tasks, clients, labels, workflows, settings) MUST be saved 
   ONLY in browser localStorage - NEVER send to external servers
2. NO external API calls for core functionality - everything must work offline
3. All data persistence must use localStorage.setItem/getItem only
4. External CDN resources (Font Awesome, SortableJS) may fail offline but 
   core functionality should degrade gracefully
5. Privacy-first: All data stays on user's device - no cloud sync, no analytics
6. Test offline functionality: Load page once online, then disconnect and verify
   all features still work

BACKWARDS COMPATIBILITY - CRITICAL:
When adding new features or data structures, ALWAYS ensure backwards compatibility:
- Import functions MUST gracefully handle missing fields (clientsMeta, clientLabels, 
  simpleLabels, workflows, etc.)
- Older export files without new fields should import successfully
- New properties should be optional with sensible defaults
- Always check if properties exist before accessing them (use optional chaining or 
  existence checks)
- Test imports with old export files before releasing changes
- When adding new localStorage keys, ensure old data still loads correctly

Current localStorage keys:
- legalTasks, legalCustomers, legalClientsMeta, legalClientLabels, legalSimpleLabels,
  legalSettings, legalExportLog

DO NOT ADD:
- External API calls for data storage
- Cloud sync features
- Analytics tracking
- Server-side data storage
- Breaking changes to data structures without migration logic

The app should work completely offline after first load, with all data stored
locally on the user's PC for full privacy and offline access.
================================================================================
-->
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Legal Task Manager</title>
    <link rel="manifest" href="manifest.json">
    <meta name="theme-color" content="#2c3e50">
    <link rel="icon" href="data:image/svg+xml,<svg xmlns=%22http://www.w3.org/2000/svg%22 viewBox=%220 0 100 100%22><text y=%22.9em%22 font-size=%2290%22>⚖️</text></svg>">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" rel="stylesheet">
    <script src="https://cdn.jsdelivr.net/npm/sortablejs@1.15.0/Sortable.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --primary-color: #2c3e50;
            --secondary-color: #3498db;
            --accent-color: #e74c3c;
            --success-color: #27ae60;
            --warning-color: #f39c12;
            --light-bg: #ecf0f1;
            --dark-text: #2c3e50;
            --light-text: #7f8c8d;
            --white: #ffffff;
            --shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
            --shadow-hover: 0 8px 25px rgba(0, 0, 0, 0.15);
            --border-radius: 12px;
            --transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            color: var(--dark-text);
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
            color: var(--white);
        }

        .header h1 {
            font-size: 2.5rem;
            font-weight: 700;
            margin-bottom: 10px;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.3);
        }

        .header p {
            font-size: 1.1rem;
            opacity: 0.9;
        }

        .main-content {
            display: grid;
            grid-template-columns: 1fr 2fr;
            gap: 30px;
            margin-bottom: 30px;
        }

        .sidebar {
            display: flex;
            flex-direction: column;
            gap: 20px;
        }

        .add-task-container, .filters-container {
            background: var(--white);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .add-task-container:hover, .filters-container:hover {
            box-shadow: var(--shadow-hover);
        }

        .reminder-options {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(120px, 1fr));
            gap: 10px;
            margin-bottom: 15px;
            transition: var(--transition);
            overflow: hidden;
        }

        .reminder-options.hide-quick {
            max-height: 0;
            opacity: 0;
            margin-bottom: 0;
            transform: translateY(-20px);
        }

        .reminder-btn {
            padding: 8px 12px;
            border: 2px solid #e0e6ed;
            background: var(--white);
            border-radius: 6px;
            cursor: pointer;
            transition: var(--transition);
            text-align: center;
            font-size: 0.9rem;
            transform: translateY(0);
            opacity: 1;
        }

        .reminder-btn:hover {
            border-color: var(--secondary-color);
            transform: translateY(-2px);
        }

        .reminder-btn.active {
            background: var(--secondary-color);
            color: var(--white);
            border-color: var(--secondary-color);
        }

        .custom-datetime {
            max-height: 0;
            opacity: 0;
            margin-top: 0;
            overflow: hidden;
            transition: all 0.4s cubic-bezier(0.4, 0, 0.2, 1);
            transform: translateY(-10px);
        }

        .custom-datetime.show {
            max-height: 100px;
            opacity: 1;
            margin-top: 15px;
            transform: translateY(0);
        }

        .form-control {
            width: 100%;
            padding: 12px 15px;
            border: 2px solid #e0e6ed;
            border-radius: 8px;
            font-size: 1rem;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            transition: var(--transition);
            background: var(--white);
        }

        .form-group {
            margin-bottom: 20px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: var(--dark-text);
        }

        .sub-tasks {
            margin: 10px 0;
            padding: 0;
            list-style: none;
        }

        .sub-task {
            display: flex;
            align-items: flex-start;
            gap: 8px;
            padding: 6px 8px;
            border-bottom: 1px solid rgba(0,0,0,0.05);
            transition: background-color 0.2s ease;
            border-radius: 4px;
        }

        .sub-task:last-child {
            border-bottom: none;
        }

        .sub-task:hover {
            background: rgba(52, 152, 219, 0.05);
        }

        .sub-task-checkbox {
            margin-top: 2px;
            cursor: pointer;
            transform: scale(1.1);
        }

        .sub-task-text {
            flex: 1;
            font-size: 0.9rem;
            line-height: 1.4;
            transition: var(--transition);
        }

        .sub-task-text.completed {
            text-decoration: line-through;
            color: var(--light-text);
            opacity: 0.7;
        }

        .sub-task-progress {
            font-size: 0.8rem;
            color: var(--secondary-color);
            font-weight: 600;
            margin-top: 5px;
        }

        .form-control:focus {
            outline: none;
            border-color: var(--secondary-color);
            box-shadow: 0 0 0 3px rgba(52, 152, 219, 0.1);
        }

        .btn {
            padding: 12px 24px;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 8px;
            text-decoration: none;
        }

        .btn-primary {
            background: var(--secondary-color);
            color: var(--white);
        }

        .btn-primary:hover {
            background: #2980b9;
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .btn-success {
            background: var(--success-color);
            color: var(--white);
        }

        .btn-success:hover {
            background: #219a52;
        }

        .btn-danger {
            background: var(--accent-color);
            color: var(--white);
        }

        .btn-danger:hover {
            background: #c0392b;
        }

        .btn-sm {
            padding: 6px 12px;
            font-size: 0.875rem;
        }

        .filters {
            margin-bottom: 20px;
        }

        .filter-group {
            margin-bottom: 15px;
        }

        .customer-list {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #e0e6ed;
            border-radius: 8px;
            padding: 10px;
        }

        .customer-item {
            padding: 8px 12px;
            cursor: pointer;
            border-radius: 6px;
            transition: var(--transition);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .customer-item:hover {
            background: var(--light-bg);
        }

        .customer-item.active {
            background: var(--secondary-color);
            color: var(--white);
        }

        .customer-count {
            background: rgba(255, 255, 255, 0.2);
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.75rem;
        }

        .task-area {
            background: var(--white);
            border-radius: var(--border-radius);
            padding: 25px;
            box-shadow: var(--shadow);
            transition: var(--transition);
        }

        .task-area:hover {
            box-shadow: var(--shadow-hover);
        }

        .tabs {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 25px;
            border-bottom: 2px solid var(--light-bg);
        }

        .tabs-container {
            display: flex;
        }

        .tab-actions {
            display: flex;
            gap: 10px;
            margin-right: 10px;
        }

        .tab-action-btn {
            background: none;
            border: none;
            color: var(--light-text);
            cursor: pointer;
            font-size: 1.1rem;
            padding: 8px 12px;
            border-radius: 6px;
            transition: var(--transition);
            position: relative;
        }

        .tab-action-btn:hover {
            background: var(--light-bg);
            color: var(--secondary-color);
            transform: translateY(-1px);
        }

        .tab-action-btn:active {
            transform: translateY(0);
        }

        .tab {
            padding: 12px 24px;
            cursor: pointer;
            border-bottom: 3px solid transparent;
            transition: var(--transition);
            font-weight: 600;
            position: relative;
        }

        .tab.active {
            color: var(--secondary-color);
            border-bottom-color: var(--secondary-color);
        }

        .tab:hover {
            background: var(--light-bg);
        }

        .tab-badge {
            background: var(--secondary-color);
            color: var(--white);
            padding: 2px 6px;
            border-radius: 12px;
            font-size: 0.75rem;
            margin-left: 8px;
            align-self: center;
            height: fit-content;
            line-height: 1;
        }

        .task-list {
            min-height: 300px;
        }

        .task-item {
            background: var(--white);
            border: 2px solid #f8f9fa;
            border-radius: 10px;
            padding: 20px;
            margin-bottom: 15px;
            transition: var(--transition);
            position: relative;
            overflow: hidden;
        }

        .task-controls {
            position: absolute;
            top: 15px;
            right: 15px;
            display: flex;
            gap: 8px;
            opacity: 0.6;
            transition: var(--transition);
        }

        .task-item:hover .task-controls {
            opacity: 1;
        }

        .task-control-btn {
            background: none;
            border: none;
            color: #95a5a6;
            cursor: pointer;
            font-size: 1rem;
            padding: 4px;
            border-radius: 4px;
            transition: var(--transition);
        }

        .task-control-btn:hover {
            background: rgba(0,0,0,0.05);
            color: var(--dark-text);
        }

        .task-control-btn.delete:hover {
            color: var(--accent-color);
            background: rgba(231, 76, 60, 0.1);
        }

        .task-item:hover {
            border-color: var(--secondary-color);
            transform: translateY(-2px);
            box-shadow: var(--shadow-hover);
        }

        .task-item.completed {
            opacity: 0.7;
            background: #f8f9fa;
        }

        .task-item.completed .task-title {
            text-decoration: line-through;
            color: var(--light-text);
        }

        /* Client expandable items */
        .client-item {
            overflow: hidden;
        }

        .client-tasks-list {
            overflow: hidden;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            will-change: max-height, opacity;
            background: rgba(52, 152, 219, 0.03);
            border-radius: 8px;
            padding: 0;
        }

        .client-tasks-inner {
            padding: 15px;
        }

        .client-tasks-section {
            margin-bottom: 15px;
        }

        .client-tasks-section:last-child {
            margin-bottom: 0;
        }

        .client-task-item {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin-bottom: 6px;
            background: var(--white);
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }

        .client-task-item:hover {
            background: rgba(52, 152, 219, 0.08);
            border-color: var(--secondary-color);
            transform: translateX(4px);
        }

        .client-task-item span {
            flex: 1;
            font-size: 0.95rem;
            color: var(--dark-text);
        }

        /* Client timeline */
        .client-timeline {
            display: flex;
            align-items: flex-start;
            gap: 18px;
            overflow-x: auto;
            padding: 10px 4px;
        }

        .client-timeline.builder-preview {
            min-height: 70px;
        }

        .client-timeline::-webkit-scrollbar {
            height: 6px;
        }

        .client-timeline::-webkit-scrollbar-thumb {
            background: rgba(52, 152, 219, 0.4);
            border-radius: 999px;
        }

        .timeline-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 140px;
            flex-shrink: 0;
        }

        .timeline-phase {
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.85rem;
            font-weight: 600;
            background: #e0e6ed;
            color: var(--dark-text);
            cursor: pointer;
            transition: var(--transition);
            border: 1px solid transparent;
            box-shadow: var(--shadow-soft);
        }

        .timeline-phase.is-past {
            background: var(--success-color);
            color: var(--white);
        }

        .timeline-phase.is-current {
            background: var(--secondary-color);
            color: var(--white);
            box-shadow: var(--shadow-hover);
        }

        .timeline-phase.is-future {
            background: #edf2f7;
            color: var(--light-text);
        }

        .timeline-track {
            display: flex;
            align-items: center;
            gap: 10px;
            padding: 6px 0;
        }

        .timeline-subphase {
            padding: 4px 10px;
            border-radius: 999px;
            background: #e0e6ed;
            color: var(--dark-text);
            font-size: 0.75rem;
            cursor: pointer;
            transition: var(--transition);
            white-space: nowrap;
            opacity: 0.9;
        }

        .timeline-subphase.is-past {
            background: rgba(46, 204, 113, 0.9);
            color: var(--white);
        }

        .timeline-subphase.is-current {
            background: var(--secondary-color);
            color: var(--white);
            box-shadow: var(--shadow-soft);
        }

        .timeline-subphase.is-future {
            background: #f3f4f6;
            color: var(--light-text);
        }

        .timeline-column-connector,
        .timeline-track-connector {
            height: 2px;
            background: #d2d6dc;
            flex-shrink: 0;
        }

        .timeline-column-connector.is-past,
        .timeline-track-connector.is-past {
            background: var(--success-color);
        }

        .timeline-column-connector {
            width: 36px;
            align-self: center;
        }

        .timeline-track-connector {
            width: 22px;
        }

        /* Label builder */
        .label-builder-section {
            margin-top: 20px;
        }

        .label-builder-section label {
            font-weight: 600;
        }

        .label-builder-hint {
            font-size: 0.85rem;
            color: var(--light-text);
            margin-top: 4px;
        }

        .label-builder-canvas {
            border: 1px solid #e0e6ed;
            border-radius: 14px;
            padding: 16px;
            margin-top: 14px;
            background: var(--white);
            min-height: 130px;
            box-shadow: var(--shadow-soft);
        }

        .builder-scroll {
            display: flex;
            align-items: flex-start;
            gap: 16px;
            overflow-x: auto;
            padding-bottom: 6px;
        }

        .builder-scroll::-webkit-scrollbar {
            height: 6px;
        }

        .builder-scroll::-webkit-scrollbar-thumb {
            background: rgba(52, 152, 219, 0.4);
            border-radius: 999px;
        }

        .label-builder-empty {
            text-align: center;
            color: var(--light-text);
            font-size: 0.9rem;
            padding: 20px 0;
        }

        .label-builder-empty button {
            margin-top: 10px;
            border: 1px dashed var(--secondary-color);
            background: transparent;
            color: var(--secondary-color);
            border-radius: 999px;
            padding: 6px 18px;
            cursor: pointer;
        }

        .builder-column {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 10px;
            min-width: 165px;
        }

        .builder-phase-chip {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 14px;
            border-radius: 999px;
            background: #edf2f7;
            border: 1px solid transparent;
            box-shadow: var(--shadow-soft);
            transition: var(--transition);
            cursor: pointer;
            min-height: 42px;
        }

        .builder-phase-chip.is-active {
            border-color: var(--secondary-color);
            background: rgba(52, 152, 219, 0.1);
        }

        .builder-phase-chip.is-sub {
            background: #f6f8fb;
            font-size: 0.8rem;
            color: var(--dark-text);
        }

        .builder-phase-chip.is-sub .builder-phase-input {
            font-size: 0.8rem;
            color: var(--dark-text);
        }

        .builder-phase-input {
            border: none;
            background: transparent;
            font-weight: 600;
            font-size: 0.9rem;
            width: 120px;
        }

        .builder-phase-input::placeholder {
            color: var(--light-text);
            font-weight: 400;
        }

        .builder-phase-input:focus {
            outline: none;
        }

        .builder-chip-actions {
            display: inline-flex;
            gap: 6px;
            align-items: center;
        }

        .builder-chip-actions button {
            border: none;
            background: rgba(255, 255, 255, 0.7);
            min-width: 34px;
            height: 30px;
            border-radius: 999px;
            display: inline-flex;
            align-items: center;
            justify-content: center;
            color: var(--secondary-color);
            cursor: pointer;
            transition: var(--transition);
            padding: 0 12px;
            gap: 6px;
            font-size: 0.75rem;
            font-weight: 600;
        }

        .builder-chip-actions button:hover {
            background: var(--secondary-color);
            color: var(--white);
        }

        .builder-chip-actions button .builder-template-chevron {
            font-size: 0.65rem;
            transition: transform 0.2s ease;
        }

        .builder-chip-actions button.builder-template-btn.is-open .builder-template-chevron {
            transform: rotate(180deg);
        }

        .builder-template-chevron {
            font-size: 0.65rem;
            margin-left: 2px;
        }

        .builder-chip-actions button.delete {
            color: var(--accent-color);
            background: rgba(231, 76, 60, 0.15);
        }

        .builder-chip-actions button.delete:hover {
            background: var(--accent-color);
            color: var(--white);
        }

        .builder-phase-chip.expanded {
            background: var(--white);
            border-color: var(--secondary-color);
            box-shadow: var(--shadow-hover);
        }

        .builder-phase-block {
            width: 100%;
        }

        .builder-sub-track {
            display: flex;
            align-items: flex-start;
            gap: 12px;
            flex-wrap: wrap;
            justify-content: center;
        }

        .builder-sub-track.level-1 {
            margin-top: 8px;
        }

        .builder-sub-track.level-2 {
            margin-top: 6px;
            padding-left: 10px;
        }

        .builder-add-chip {
            border: 1px dashed var(--secondary-color);
            background: transparent;
            color: var(--secondary-color);
            padding: 6px 14px;
            border-radius: 999px;
            font-size: 0.85rem;
            cursor: pointer;
            transition: var(--transition);
            display: inline-flex;
            align-items: center;
            gap: 6px;
        }

        .builder-add-chip.small {
            padding: 4px 10px;
            font-size: 0.75rem;
        }

        .builder-add-chip:hover {
            background: rgba(52, 152, 219, 0.08);
        }

        .builder-phase-tasks {
            width: 100%;
            background: rgba(52, 152, 219, 0.04);
            border: 1px solid #e0e6ed;
            border-radius: 12px;
            margin-top: 10px;
            padding: 0 12px 12px;
            overflow: hidden;
            max-height: 0;
            opacity: 0;
            display: none;
            transition: max-height 0.3s cubic-bezier(0.4, 0, 0.2, 1), opacity 0.3s cubic-bezier(0.4, 0, 0.2, 1);
        }

        .builder-phase-tasks.show {
            display: block;
            opacity: 1;
        }

        .builder-task-list {
            display: flex;
            flex-direction: column;
            gap: 8px;
            padding: 12px 0;
        }

        .builder-empty-tasks {
            color: var(--light-text);
            font-size: 0.85rem;
        }

        .builder-task-row {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 6px 10px;
            border: 1px solid #e0e6ed;
            border-radius: 10px;
            background: var(--white);
        }

        .builder-task-row input {
            flex: 1;
            border: none;
            background: transparent;
        }

        .builder-task-row input:focus {
            outline: none;
        }

        .builder-task-row button {
            border: none;
            border-radius: 8px;
            width: 26px;
            height: 26px;
            display: flex;
            align-items: center;
            justify-content: center;
            cursor: pointer;
            transition: var(--transition);
        }

        .builder-task-row button.builder-task-confirm {
            background: rgba(46, 204, 113, 0.2);
            color: var(--success-color);
        }

        .builder-task-row button.builder-task-confirm:hover {
            background: var(--success-color);
            color: var(--white);
        }

        .builder-task-row button.builder-task-edit {
            background: rgba(52, 152, 219, 0.15);
            color: var(--secondary-color);
        }

        .builder-task-row button.builder-task-edit:hover {
            background: var(--secondary-color);
            color: var(--white);
        }

        .builder-task-row button.builder-task-delete {
            background: rgba(231, 76, 60, 0.15);
            color: var(--accent-color);
        }

        .builder-task-row button.builder-task-delete:hover {
            background: var(--accent-color);
            color: var(--white);
        }

        .builder-task-row.confirmed {
            animation: pulseConfirm 0.45s ease;
        }

        @keyframes pulseConfirm {
            0% { box-shadow: 0 0 0 rgba(46, 204, 113, 0); }
            50% { box-shadow: 0 0 12px rgba(46, 204, 113, 0.4); }
            100% { box-shadow: 0 0 0 rgba(46, 204, 113, 0); }
        }

        .builder-add-task-btn {
            border: 1px dashed var(--secondary-color);
            background: transparent;
            color: var(--secondary-color);
            padding: 6px 12px;
            border-radius: 8px;
            cursor: pointer;
            width: 100%;
        }

        /* Manage labels modal */
        .labels-modal-list {
            display: flex;
            flex-direction: column;
            gap: 12px;
            margin-top: 10px;
            max-height: 320px;
            overflow-y: auto;
            padding: 12px;
            background: var(--light-bg);
            border-radius: 10px;
        }

        .labels-modal-list::-webkit-scrollbar {
            width: 6px;
        }

        .labels-modal-list::-webkit-scrollbar-thumb {
            background: rgba(52, 152, 219, 0.4);
            border-radius: 999px;
        }

        .labels-modal-empty {
            text-align: center;
            color: var(--light-text);
            font-size: 0.9rem;
            padding: 30px 10px;
        }

        .label-card {
            display: flex;
            align-items: center;
            justify-content: space-between;
            padding: 14px 16px;
            border-radius: 12px;
            border: 1px solid #e0e6ed;
            background: var(--white);
            box-shadow: var(--shadow-soft);
            cursor: pointer;
            transition: var(--transition);
        }

        .label-card:hover {
            border-color: var(--secondary-color);
            box-shadow: var(--shadow-hover);
            transform: translateY(-2px);
        }

        .label-card.selected {
            border-color: var(--secondary-color);
            background: rgba(52, 152, 219, 0.08);
        }

        .label-card-left {
            display: flex;
            align-items: center;
            gap: 12px;
        }

        .label-badge {
            width: 40px;
            height: 40px;
            border-radius: 10px;
            display: flex;
            align-items: center;
            justify-content: center;
            background: #f0f4f8;
            color: var(--secondary-color);
            font-size: 1rem;
            box-shadow: var(--shadow-soft);
        }

        .label-card.selected .label-badge {
            background: var(--secondary-color);
            color: var(--white);
        }

        .label-card-title {
            font-weight: 600;
            color: var(--dark-text);
            font-size: 0.95rem;
        }

        .label-card-meta {
            display: flex;
            align-items: center;
            gap: 8px;
            font-size: 0.8rem;
            color: var(--light-text);
            margin-top: 2px;
        }

        .label-selected-pill {
            display: inline-flex;
            align-items: center;
            gap: 4px;
            padding: 2px 8px;
            border-radius: 999px;
            background: rgba(46, 204, 113, 0.15);
            color: var(--success-color);
            font-weight: 600;
            font-size: 0.75rem;
        }

        .label-card-actions {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .label-edit-btn {
            border: none;
            background: rgba(52, 152, 219, 0.12);
            color: var(--secondary-color);
            padding: 6px 10px;
            border-radius: 8px;
            font-size: 0.8rem;
            cursor: pointer;
            transition: var(--transition);
        }

        .label-edit-btn:hover {
            background: var(--secondary-color);
            color: var(--white);
        }

        .client-item:hover {
            border-color: var(--secondary-color);
        }

        .client-item.archived {
            opacity: 0.7;
        }

        .client-archived-badge {
            display: inline-flex;
            align-items: center;
            gap: 6px;
            margin-left: 10px;
            padding: 2px 8px;
            border-radius: 10px;
            font-size: 0.75rem;
            color: var(--light-text);
            background: rgba(127, 140, 141, 0.15);
            border: 1px solid rgba(127, 140, 141, 0.25);
        }

        .task-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 12px;
        }

        .task-title {
            font-size: 1.1rem;
            font-weight: 600;
            color: var(--dark-text);
            margin-bottom: 5px;
        }

        .task-customer {
            background: var(--secondary-color);
            color: var(--white);
            padding: 4px 10px;
            border-radius: 15px;
            font-size: 0.8rem;
            font-weight: 500;
        }

        .task-meta {
            display: flex;
            align-items: center;
            gap: 15px;
            margin-bottom: 15px;
            font-size: 0.9rem;
            color: var(--light-text);
        }

        .task-reminder {
            display: flex;
            align-items: center;
            gap: 5px;
        }

        .task-reminder.overdue {
            color: var(--accent-color);
            font-weight: 600;
        }

        .task-actions {
            display: flex;
            justify-content: space-between;
            align-items: center;
            gap: 10px;
        }

        .task-deadline {
            font-size: 0.85rem;
            padding: 4px 8px;
            border-radius: 12px;
            font-weight: 500;
            background: var(--light-bg);
            color: var(--light-text);
            user-select: text;
            cursor: text;
        }

        .task-deadline.overdue {
            background: var(--accent-color);
            color: var(--white);
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% { opacity: 1; }
            50% { opacity: 0.8; }
            100% { opacity: 1; }
        }

        .task-action-buttons {
            display: flex;
            gap: 10px;
        }

        .empty-state {
            text-align: center;
            padding: 60px 20px;
            color: var(--light-text);
        }

        .empty-state i {
            font-size: 4rem;
            margin-bottom: 20px;
            opacity: 0.5;
        }

        .empty-state h3 {
            font-size: 1.5rem;
            margin-bottom: 10px;
        }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 15px 20px;
            border-radius: 8px;
            color: var(--white);
            font-weight: 600;
            z-index: 1000;
            transform: translateX(400px);
            transition: var(--transition);
        }

        .notification.show {
            transform: translateX(0);
        }

        .notification.success {
            background: var(--success-color);
        }

        .notification.error {
            background: var(--accent-color);
        }

        .notification.warning {
            background: var(--warning-color);
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(150px, 1fr));
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: linear-gradient(135deg, var(--secondary-color), #3498db);
            color: var(--white);
            padding: 20px;
            border-radius: 10px;
            text-align: center;
            box-shadow: var(--shadow);
            transition: var(--transition);
            border: none;
            outline: none;
            display: block;
            width: 100%;
        }

        .stat-card:hover {
            transform: translateY(-3px);
            box-shadow: var(--shadow-hover);
        }

        .stat-number {
            font-size: 2rem;
            font-weight: 700;
            margin-bottom: 5px;
        }

        .stat-label {
            font-size: 0.9rem;
            opacity: 0.9;
        }

        .search-box {
            position: relative;
            margin-bottom: 20px;
        }

        .search-box input {
            padding-left: 45px;
        }

        .search-box i {
            position: absolute;
            left: 15px;
            top: 50%;
            transform: translateY(-50%);
            color: var(--light-text);
        }

        .fade-in {
            animation: fadeIn 0.5s ease-in;
        }

        .slide-in {
            animation: slideIn 0.3s ease-out;
        }

        @keyframes fadeIn {
            from { opacity: 0; transform: translateY(20px); }
            to { opacity: 1; transform: translateY(0); }
        }

        @keyframes slideIn {
            from { transform: translateX(-20px); opacity: 0; }
            to { transform: translateX(0); opacity: 1; }
        }

        @media (max-width: 768px) {
            .main-content {
                grid-template-columns: 1fr;
                gap: 20px;
            }
            
            .header h1 {
                font-size: 2rem;
            }
            
            .stats {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .reminder-options {
                grid-template-columns: repeat(2, 1fr);
            }
            
            .sidebar {
                gap: 15px;
            }
            
            .add-task-container, .filters-container {
                padding: 20px;
            }
        }

        .offline-indicator {
            position: fixed;
            bottom: 20px;
            left: 20px;
            background: var(--accent-color);
            color: var(--white);
            padding: 10px 15px;
            border-radius: 25px;
            font-size: 0.9rem;
            transform: translateY(100px);
            transition: var(--transition);
            z-index: 1000;
        }

        .offline-indicator.show {
            transform: translateY(0);
        }

        .task-info-modal {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.5);
            display: none;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            opacity: 0;
            transition: var(--transition);
        }

        .task-info-modal.show {
            display: flex;
            opacity: 1;
        }

        .task-info-content {
            background: var(--white);
            border-radius: var(--border-radius);
            padding: 25px;
            max-width: 400px;
            width: 90%;
            box-shadow: var(--shadow-hover);
            transform: scale(0.9);
            transition: var(--transition);
        }

        .task-info-modal.show .task-info-content {
            transform: scale(1);
        }

        .task-info-header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 20px;
            padding-bottom: 15px;
            border-bottom: 2px solid var(--light-bg);
        }

        .task-info-close {
            background: none;
            border: none;
            font-size: 1.5rem;
            color: var(--light-text);
            cursor: pointer;
            transition: var(--transition);
        }

        .task-info-close:hover {
            color: var(--dark-text);
        }

        .task-info-item {
            margin-bottom: 15px;
            padding: 10px;
            background: var(--light-bg);
            border-radius: 8px;
        }

        .task-info-label {
            font-weight: 600;
            color: var(--primary-color);
            margin-bottom: 5px;
        }

        .task-info-value {
            color: var(--dark-text);
        }

        /* Drag and Drop Styles */
        .task-item {
            cursor: grab;
        }
        
        .task-title, .task-customer, .sub-task-text {
            user-select: text;
            cursor: text;
        }
        
        .task-item div[style*="color: var(--light-text)"] {
            user-select: text;
            cursor: text;
        }

        .task-item:active {
            cursor: grabbing;
        }

        .task-item.sortable-ghost {
            opacity: 0.5;
            transform: rotate(2deg);
            background: var(--light-bg);
            border: 2px dashed var(--secondary-color);
        }

        .task-item.sortable-chosen {
            transform: scale(1.02);
            box-shadow: var(--shadow-hover);
            z-index: 1000;
        }

        .task-item.sortable-drag {
            opacity: 0.8;
            transform: rotate(-1deg);
        }

        .task-list {
            min-height: 300px;
            position: relative;
        }

        .task-item {
            position: relative;
        }

        .task-item:not(.completed):not(.task-completing) {
            cursor: grab;
        }

        .task-item:not(.completed):not(.task-completing):active {
            cursor: grabbing;
        }

        /* Smooth completion animation */
        .task-completing {
            animation: taskComplete 0.6s ease-out forwards;
            pointer-events: none;
        }

        @keyframes taskComplete {
            0% {
                opacity: 1;
                transform: translateY(0) scale(1);
            }
            50% {
                opacity: 0.7;
                transform: translateY(-10px) scale(1.02);
                background: var(--success-color);
                color: white;
            }
            100% {
                opacity: 0;
                transform: translateY(-20px) scale(0.95);
                height: 0;
                margin: 0;
                padding: 0;
            }
        }

        .drop-zone-indicator {
            height: 4px;
            background: var(--secondary-color);
            border-radius: 2px;
            margin: 5px 0;
            opacity: 0;
            transform: scaleX(0);
            transition: all 0.3s ease;
        }

        .drop-zone-indicator.active {
            opacity: 1;
            transform: scaleX(1);
        }

        .customer-suggestions {
            position: absolute;
            top: 100%;
            left: 0;
            right: 0;
            background: var(--white);
            border: 2px solid var(--secondary-color);
            border-top: none;
            border-radius: 0 0 8px 8px;
            max-height: 200px;
            overflow-y: auto;
            z-index: 1000;
            box-shadow: var(--shadow);
        }

        .customer-suggestion {
            padding: 10px 15px;
            cursor: pointer;
            transition: var(--transition);
            border-bottom: 1px solid #f0f0f0;
        }

        .customer-suggestion:last-child {
            border-bottom: none;
        }

        .customer-suggestion:hover, .customer-suggestion.highlighted {
            background: var(--light-bg);
            color: var(--secondary-color);
        }

        .customer-suggestion.highlighted {
            background: var(--secondary-color);
            color: var(--white);
        }
        /* Clients avatar + assigned badge */
        .client-avatar {
            position: relative;
            width: 36px;
            height: 36px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #fff;
        }

        .client-assigned-badge {
            position: absolute;
            right: -4px;
            bottom: -4px;
            background: #2ecc71;
            color: #fff;
            border-radius: 50%;
            width: 16px;
            height: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            box-shadow: 0 0 0 2px #fff;
            transition: all 0.18s ease;
        }

        .client-avatar:hover .client-assigned-badge {
            transform: scale(1.2);
        }

        .client-assigned-badge::after {
            content: '';
            position: absolute;
            right: 20px;
            bottom: 0;
            background: #2ecc71;
            color: #fff;
            padding: 2px 6px;
            border-radius: 10px;
            font-size: 11px;
            white-space: nowrap;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.18s ease;
        }

        .client-avatar:hover .client-assigned-badge::after {
            content: 'Assigned to me';
            opacity: 1;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1><i class="fas fa-balance-scale"></i> Legal Task Manager</h1>
            <p>Privacy-first task management for legal professionals 
                <i class="fas fa-info-circle" onclick="showPrivacyInfo()" style="cursor: pointer; margin-left: 8px; opacity: 0.8;" title="Learn about our privacy protection"></i>
            </p>
        </div>

        <div class="stats">
            <button class="stat-card" onclick="openPendingFromStats(true)" title="Show Overdue">
                <div class="stat-number" id="overdueReminders">0</div>
                <div class="stat-label">Overdue</div>
            </button>
            <button class="stat-card" onclick="openPendingFromStats(false)" title="Open Pending">
                <div class="stat-number" id="pendingTasks">0</div>
                <div class="stat-label">Pending</div>
            </button>
            <button class="stat-card" onclick="openCompletedFromStats()" title="Open Completed">
                <div class="stat-number" id="completedTasks">0</div>
                <div class="stat-label">Completed</div>
            </button>
            <button class="stat-card" onclick="openClientsFromStats()" title="Open Clients">
                <div class="stat-number" id="totalTasks">0</div>
                <div class="stat-label">Clients</div>
            </button>
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="add-task-container">
                    <h3 style="margin-bottom: 20px; color: var(--primary-color);">
                        <i class="fas fa-plus-circle"></i> Add New Task
                    </h3>
                    
                    <div class="form-group">
                        <label for="taskTitle">Task Title *</label>
                        <input type="text" id="taskTitle" class="form-control" placeholder="e.g., Send email to client" required onkeypress="handleEnterKey(event)">
                    </div>
                    
                    <div class="form-group">
                        <label for="taskDescription">Description</label>
                        <textarea id="taskDescription" class="form-control" placeholder="Additional details about the task..." rows="3" onkeypress="handleEnterKey(event)"></textarea>
                    </div>
                    
                    <div class="form-group">
                        <label for="customerName">Customer/Client</label>
                        <div style="position: relative;">
                            <input type="text" id="customerName" class="form-control" placeholder="Type customer name..." onkeypress="handleEnterKey(event)" oninput="showCustomerSuggestions()" onblur="hideCustomerSuggestions()" onfocus="showCustomerSuggestions()">
                            <div id="customerSuggestions" class="customer-suggestions" style="display: none;"></div>
                        </div>
                    </div>
                    
                    <div class="form-group">
                        <label>Reminder</label>
                        <div class="reminder-options">
                            <button type="button" class="reminder-btn" onclick="setReminderOption('3h')">In 3 hours</button>
                            <button type="button" class="reminder-btn" onclick="setReminderOption('1d')">In 1 day</button>
                            <button type="button" class="reminder-btn" onclick="setReminderOption('custom')">Custom</button>
                            <button type="button" class="reminder-btn" onclick="setReminderOption('none')">No reminder</button>
                        </div>
                        <div class="custom-datetime" id="customDateTime">
                            <input type="datetime-local" id="reminderDateTime" class="form-control" onkeypress="handleEnterKey(event)">
                        </div>
                    </div>
                    
                    <button class="btn btn-primary" onclick="addTask()">
                        <i class="fas fa-plus"></i> Add Task
                    </button>
                </div>

                <div class="filters-container">
                    <h4 style="margin-bottom: 15px; color: var(--primary-color);">
                        <i class="fas fa-filter"></i> Filters
                    </h4>
                    
                    <div class="search-box">
                        <input type="text" id="searchTasks" class="form-control" placeholder="Search tasks..." oninput="filterTasks()">
                        <i class="fas fa-search"></i>
                    </div>
                    
                    <div class="filter-group">
                        <label>
                            <input type="checkbox" id="showCompleted" onchange="filterTasks()"> 
                            Show completed tasks
                        </label>
                    </div>
                    
                    <div class="filter-group">
                        <label for="customerFilter">Filter by Customer:</label>
                        <div class="customer-list" id="customerList">
                            <div class="customer-item active" onclick="selectCustomer('')">
                                <span><i class="fas fa-users"></i> All Customers</span>
                                <span class="customer-count" id="allCustomerCount">0</span>
                            </div>
                        </div>
                    </div>
                </div>
            </div>

            <div class="task-area">
                <div class="tabs">
                    <div class="tabs-container">
                        <div class="tab active" onclick="switchTab('pending')">
                            <i class="fas fa-clock"></i> Pending Tasks
                            <span class="tab-badge" id="pendingBadge">0</span>
                        </div>
                        <div class="tab" onclick="switchTab('completed')">
                            <i class="fas fa-check-circle"></i> Completed Tasks
                            <span class="tab-badge" id="completedBadge">0</span>
                        </div>
                        <div class="tab" onclick="switchTab('clients')">
                            <i class="fas fa-users"></i> Clients
                            <span class="tab-badge" id="clientsBadge">0</span>
                        </div>
                    </div>
                    <div class="tab-actions">
                        <button class="tab-action-btn" id="myClientsToggle" onclick="toggleMyClientsOnly()" title="Show only my clients" style="display: none;">
                            <i class="fas fa-user-check"></i>
                        </button>
                        <button class="tab-action-btn" onclick="openSettings()" title="Settings">
                            <i class="fas fa-cog"></i>
                        </button>
                    </div>
                </div>

                <div class="task-list" id="taskList">
                    <div class="empty-state">
                        <i class="fas fa-clipboard-list"></i>
                        <h3>No tasks yet</h3>
                        <p>Add your first task to get started with managing your legal work.</p>
                    </div>
                </div>
            </div>
        </div>
    </div>

    <div class="offline-indicator" id="offlineIndicator">
        <i class="fas fa-wifi"></i> Working Offline
    </div>

    <div class="task-info-modal" id="taskInfoModal">
        <div class="task-info-content">
            <div class="task-info-header">
                <h3><i class="fas fa-info-circle"></i> Task Information</h3>
                <button class="task-info-close" onclick="closeTaskInfo()">&times;</button>
            </div>
            <div id="taskInfoContent">
                <!-- Task info will be populated here -->
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="clientInfoModal">
        <div class="task-info-content">
            <div class="task-info-header">
                <h3><i class="fas fa-user"></i> Client Information</h3>
                <button class="task-info-close" onclick="closeClientInfo()">&times;</button>
            </div>
            <div id="clientInfoContent"></div>
        </div>
    </div>

    <div class="task-info-modal" id="clientLabelsModal">
        <div class="task-info-content" style="max-width: 700px; max-height: 90vh; overflow-y: auto;">
            <div class="task-info-header">
                <h3><i class="fas fa-project-diagram"></i> Manage Workflows</h3>
                <button class="task-info-close" onclick="closeClientWorkflows()">&times;</button>
            </div>
            <div id="clientLabelsContent">
                <div class="form-group">
                    <label>Available Workflows</label>
                    <div id="labelsList" class="labels-modal-list"></div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="btn btn-primary" onclick="openCreateLabelModal()" style="flex: 1;">
                        <i class="fas fa-plus"></i> Create New Workflow
                    </button>
                    <button class="btn btn-secondary" onclick="closeClientWorkflows()" style="background: #95a5a6;">
                        <i class="fas fa-check"></i> Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="quickAddLabelModal">
        <div class="task-info-content" style="max-width: 500px;">
            <div class="task-info-header">
                <h3><i class="fas fa-tag"></i> Add Label</h3>
                <button class="task-info-close" onclick="closeQuickAddLabel()">&times;</button>
            </div>
            <div id="quickAddLabelContent" style="padding: 20px;">
                <div class="form-group">
                    <label>Select or Create Label</label>
                    <div id="quickAddLabelList" style="display: flex; flex-direction: column; gap: 8px; max-height: 300px; overflow-y: auto; margin-top: 10px;"></div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 15px;">
                    <button class="btn btn-primary" onclick="createNewSimpleLabel()" style="flex: 1;">
                        <i class="fas fa-plus"></i> Create New Label
                    </button>
                    <button class="btn btn-secondary" onclick="closeQuickAddLabel()" style="background: #95a5a6;">
                        <i class="fas fa-check"></i> Done
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="createLabelModal">
        <div class="task-info-content" style="max-width: 800px; max-height: 90vh; overflow-y: auto;">
            <div class="task-info-header">
                <h3><i class="fas fa-plus-circle"></i> Create Workflow</h3>
                <button class="task-info-close" onclick="closeCreateLabelModal()">&times;</button>
            </div>
            <div id="createLabelContent" style="padding: 20px;">
                <div class="form-group">
                    <label for="labelNameInput">Workflow Name *</label>
                    <input type="text" id="labelNameInput" class="form-control" placeholder="e.g., Criminal Proceedings" required>
                </div>
                <div class="form-group label-builder-section">
                    <label>Phases</label>
                    <div class="label-builder-hint">Design the proceeding flow inline. Tap the plus bubbles to add phases and sub-phases, then rename them directly inside the timeline.</div>
                    <div id="labelBuilderCanvas" class="label-builder-canvas">
                        <div class="label-builder-empty">
                            Tap the <strong>+ Add phase</strong> bubble to start mapping this proceeding.
                        </div>
                    </div>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveNewLabel()">
                        <i class="fas fa-save"></i> Save Workflow
                    </button>
                    <button class="btn btn-secondary" onclick="closeCreateLabelModal()" style="background: #95a5a6;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="editClientModal">
        <div class="task-info-content" style="max-width: 500px;">
            <div class="task-info-header">
                <h3><i class="fas fa-edit"></i> Edit Client</h3>
                <button class="task-info-close" onclick="closeEditClient()">&times;</button>
            </div>
            <div id="editClientContent">
                <div class="form-group">
                    <label for="editClientName">Client Name *</label>
                    <input type="text" id="editClientName" class="form-control" required>
                </div>
                <div class="form-group" style="margin-top: 10px; display:flex; align-items:center; gap:8px;">
                    <label style="margin:0;">Assignment</label>
                    <button class="task-control-btn" id="editClientAssignedBtn" onclick="toggleEditClientAssigned()" title="Toggle assignment">
                        <i class="fas fa-user-check"></i>
                    </button>
                    <input type="checkbox" id="editClientAssigned" style="display:none;">
                    <span id="editClientAssignedText" style="color: var(--light-text); font-size: 0.9rem;">Not assigned</span>
                </div>
                <div class="form-group" style="margin-top: 10px;">
                    <label for="editClientNotes">Notes</label>
                    <textarea id="editClientNotes" class="form-control" rows="4" placeholder="Enter client notes..."></textarea>
                </div>
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveClientEdit()">
                        <i class="fas fa-save"></i> Save Changes
                    </button>
                    <button class="btn btn-secondary" onclick="closeEditClient()" style="background: #95a5a6;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="editTaskModal">
        <div class="task-info-content" style="max-width: 500px;">
            <div class="task-info-header">
                <h3><i class="fas fa-edit"></i> Edit Task</h3>
                <button class="task-info-close" onclick="closeEditTask()">&times;</button>
            </div>
            <div id="editTaskContent">
                <div class="form-group">
                    <label for="editTaskTitle">Task Title *</label>
                    <input type="text" id="editTaskTitle" class="form-control" required>
                </div>
                
                <div class="form-group">
                    <label for="editTaskDescription">Description</label>
                    <textarea id="editTaskDescription" class="form-control" rows="3"></textarea>
                </div>
                
                <div class="form-group">
                    <label for="editCustomerName">Customer/Client</label>
                    <div style="position: relative;">
                        <input type="text" id="editCustomerName" class="form-control" placeholder="Type customer name..." oninput="showEditCustomerSuggestions()" onblur="hideEditCustomerSuggestions()" onfocus="showEditCustomerSuggestions()">
                        <div id="editCustomerSuggestions" class="customer-suggestions" style="display: none;"></div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Reminder</label>
                    <div class="reminder-options" id="editReminderOptions">
                        <button type="button" class="reminder-btn" onclick="setEditReminderOption('3h')">In 3 hours</button>
                        <button type="button" class="reminder-btn" onclick="setEditReminderOption('1d')">In 1 day</button>
                        <button type="button" class="reminder-btn" onclick="setEditReminderOption('custom')">Custom</button>
                        <button type="button" class="reminder-btn" onclick="setEditReminderOption('none')">No reminder</button>
                    </div>
                    <div class="custom-datetime" id="editCustomDateTime">
                        <input type="datetime-local" id="editReminderDateTime" class="form-control">
                    </div>
                </div>
                
                <div style="display: flex; gap: 10px; margin-top: 20px;">
                    <button class="btn btn-primary" onclick="saveTaskEdit()">
                        <i class="fas fa-save"></i> Save Changes
                    </button>
                    <button class="btn btn-secondary" onclick="closeEditTask()" style="background: #95a5a6;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="privacyInfoModal">
        <div class="task-info-content" style="max-width: 500px;">
            <div class="task-info-header">
                <h3><i class="fas fa-shield-alt"></i> Your Data Never Leaves Your Device</h3>
                <button class="task-info-close" onclick="closePrivacyInfo()">&times;</button>
            </div>
            <div id="privacyInfoContent">
                <div class="task-info-item">
                    <div class="task-info-label"><i class="fas fa-laptop"></i> Local Storage Only</div>
                    <div class="task-info-value">All tasks and client information are stored in your browser using HTML5 localStorage. Nothing is sent to any server.</div>
                </div>
                
                <div class="task-info-item">
                    <div class="task-info-label"><i class="fas fa-user-lock"></i> Zero Data Collection</div>
                    <div class="task-info-value">No tracking, no analytics, no accounts. Your confidential work remains completely private.</div>
                </div>
                
                <div class="task-info-item">
                    <div class="task-info-label"><i class="fas fa-wifi"></i> Works Completely Offline</div>
                    <div class="task-info-value">Full functionality without internet connection. Safe for attorney-client privileged information.</div>
                </div>
                
                <div style="margin-top: 20px; padding: 12px; background: #f8f9fa; border-radius: 6px; font-size: 0.9rem; color: var(--light-text);">
                    <strong>Technical Note:</strong> Press F12 to verify — there are no network requests to external servers.
                </div>
                
                <div style="margin-top: 15px; text-align: center; font-size: 11px; color: #999; opacity: 0.7;">
                    <span id="appVersion">v1.1.2</span> • Built with privacy in mind
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="settingsModal">
        <div class="task-info-content" style="max-width: 450px;">
            <div class="task-info-header">
                <h3><i class="fas fa-cog"></i> Settings</h3>
                <button class="task-info-close" onclick="closeSettings()">&times;</button>
            </div>
            <div id="settingsContent">
                <div style="margin-bottom: 18px; font-weight: 600; color: var(--primary-color); display: flex; align-items: center; gap: 8px;"><i class="fas fa-user-cog"></i> Clients</div>
                <div class="form-group" style="margin-bottom: 16px;">
                    <label>
                        <input type="checkbox" id="clientsTabEnabled" onchange="toggleClientsTabEnabled()"> Enable Clients tab
                    </label>
                    <p style="font-size: 0.9rem; color: var(--light-text); margin-top: 5px;">Show the Clients tab to view and manage your clients</p>
                </div>

                <hr style="margin: 14px 0; border: none; border-top: 1px solid var(--border-color);">

                <div style="margin: 8px 0 10px; font-weight: 600; color: var(--primary-color); display: flex; align-items: center; gap: 8px;"><i class="fas fa-file-export"></i> Export & Import</div>
                <div class="form-group">
                    <label>
                        <input type="checkbox" id="autoExportEnabled" onchange="toggleAutoExport()"> 
                        Enable automatic export
                    </label>
                    <p id="exportDescription" style="font-size: 0.9rem; color: var(--light-text); margin-top: 5px;">
                        Automatically export tasks as JSON file every Friday
                    </p>
                </div>
                
                <div class="form-group" id="exportDayGroup">
                    <label>Export days:</label>
                    <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 8px; margin-top: 8px;">
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay1" value="1" onchange="updateExportSettings()"> Monday
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay2" value="2" onchange="updateExportSettings()"> Tuesday
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay3" value="3" onchange="updateExportSettings()"> Wednesday
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay4" value="4" onchange="updateExportSettings()"> Thursday
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay5" value="5" onchange="updateExportSettings()"> Friday
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay6" value="6" onchange="updateExportSettings()"> Saturday
                        </label>
                        <label style="display: flex; align-items: center; gap: 8px;">
                            <input type="checkbox" id="exportDay0" value="0" onchange="updateExportSettings()"> Sunday
                        </label>
                    </div>
                </div>
                
                <div class="form-group" id="exportTimeGroup">
                    <label for="exportTime">Export time:</label>
                    <input type="time" id="exportTime" class="form-control" value="16:00" onchange="updateExportSettings()">
                </div>
                
                <div class="form-group">
                    <label>Export Statistics:</label>
                    <div style="background: var(--light-bg); padding: 15px; border-radius: 8px; margin-top: 8px;">
                        <div style="display: flex; justify-content: space-between; margin-bottom: 8px;">
                            <span>Last export:</span>
                            <span id="lastExportDate">Never</span>
                        </div>
                        <div style="display: flex; justify-content: space-between;">
                            <span>Next scheduled:</span>
                            <span id="nextExportDate">-</span>
                        </div>
                    </div>
                </div>
                
                <div class="form-group">
                    <label>Manual Export/Import:</label>
                    <div style="display: flex; gap: 10px; margin-top: 8px;">
                        <button type="button" class="reminder-btn" onclick="exportTasksAsJSON()" style="flex: 1;">
                            <i class="fas fa-upload"></i> Export Tasks
                        </button>
                        <button type="button" class="reminder-btn" onclick="importTasks()" style="flex: 1;">
                            <i class="fas fa-download"></i> Import Tasks
                        </button>
                    </div>
                    <input type="file" id="importFileInput" accept=".json" style="display: none;" onchange="handleFileImport(event)">
                </div>
                
                <hr style="margin: 20px 0; border: none; border-top: 1px solid var(--border-color);">
                
                <div style="display: flex; gap: 10px;">
                    <button class="btn btn-primary" onclick="saveSettings()">
                        <i class="fas fa-save"></i> Save Settings
                    </button>
                    <button class="btn btn-secondary" onclick="closeSettings()" style="background: #95a5a6;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                </div>
            </div>
        </div>
    </div>

    <div class="task-info-modal" id="importConfirmModal">
        <div class="task-info-content" style="max-width: 500px;">
            <div class="task-info-header">
                <h3><i class="fas fa-download"></i> Confirm Import</h3>
                <button class="task-info-close" onclick="closeImportConfirm()">&times;</button>
            </div>
            <div id="importConfirmContent">
                <div style="margin-bottom: 20px;">
                    <div style="background: var(--light-bg); padding: 15px; border-radius: 8px; margin-bottom: 15px;">
                        <div style="font-weight: 600; margin-bottom: 10px; color: var(--primary-color);">
                            <i class="fas fa-file-import"></i> Import Details
                        </div>
                        <div id="importSummary" style="line-height: 1.6;"></div>
                    </div>
                    
                    <div style="background: #e8f5e8; padding: 15px; border-radius: 8px; border-left: 4px solid #27ae60;">
                        <div style="font-weight: 600; margin-bottom: 8px; color: #27ae60;">
                            <i class="fas fa-shield-alt"></i> Your Data is Safe
                        </div>
                        <div style="color: #2c5530; font-size: 0.9rem;" id="importSafetyMessage"></div>
                    </div>
                </div>
                
                <div style="display: flex; gap: 12px; justify-content: flex-end;">
                    <button class="btn btn-secondary" onclick="closeImportConfirm()" style="background: #95a5a6;">
                        <i class="fas fa-times"></i> Cancel
                    </button>
                    <button class="btn btn-primary" onclick="confirmImport()" style="background: #27ae60;">
                        <i class="fas fa-check"></i> Import Tasks
                    </button>
                </div>
            </div>
        </div>
    </div>

    <script>
        // App version
        const APP_VERSION = 'v1.1.2';
        
        // Global variables
        let tasks = [];
        let customers = new Set();
        let currentTab = 'pending';
        let selectedCustomer = '';
        let searchTerm = '';
        let showCompleted = false;
        let selectedReminderOption = 'none';
        let selectedEditReminderOption = 'none';
        let currentEditingTaskId = null;
        let sortableInstance = null;
        let clientsSortableInstance = null;
        let clientsMeta = {};
        let myClientsOnly = false;
        let clientsTabEnabled = true;
        let clientLabels = []; // Global list of available workflows (objects with name, phases, tasks)
        let simpleLabels = []; // Global list of simple labels (just name and id, independent of workflows)
        let currentLabelClientKey = null; // Track which client's labels we're managing
        let editingLabelId = null; // Track which label is being edited
        let phaseCounter = 0; // Counter for unique phase IDs
        let labelBuilderPhases = [];
        let selectedBuilderPhaseId = null;
        let builderFocusPhaseId = null;
        let builderFocusTaskKey = null;
        let builderConfirmFlashKey = null;
        let builderExpandedPhaseIds = new Set();
        let builderConfirmedTasks = new Set(); // Track which tasks are saved/confirmed
        let autoExportEnabled = true;
        let autoExportDays = [5]; // Friday by default
        let autoExportTime = '16:00';
        let autoExportInterval = null;
        let autoExportTimeout = null;

        // Structured persistence logging helpers
        const SESSION_ID = 'S' + new Date().toISOString();
        function persistLog(event, details) {
            try { console.log(`[PERSIST][${SESSION_ID}][${event}]`, details); } catch (e) {}
        }

        // Initialize app
        document.addEventListener('DOMContentLoaded', function() {
            console.log(`%c📋 Legal Task Manager ${APP_VERSION}`, 'color: #2196F3; font-weight: bold; font-size: 14px;');
            persistLog('startup.begin', { version: APP_VERSION });
            loadTasks();
            loadSettings();
            persistLog('startup.afterLoad', {
                settings: JSON.parse(localStorage.getItem('legalTasksSettings') || '{}'),
                clientsMeta: JSON.parse(localStorage.getItem('legalClientsMeta') || '{}'),
                currentTab
            });
            // Ensure UI reflects saved settings immediately on load
            updateSettingsDisplay();
            // Switch to saved tab if needed
            if (currentTab && currentTab !== 'pending') {
                switchTab(currentTab);
            }
            persistLog('startup.afterUIApply', { currentTab, clientsTabEnabled, myClientsOnly });
            updateStats();
            updateCustomerList();
            // Only filter tasks if we're not on the clients tab (clients already rendered by switchTab)
            if (currentTab !== 'clients') {
                filterTasks();
            }
            setupNotifications();
            checkReminders();
            
            // Initialize reminder option
            setReminderOption('none');
            
            // Set up periodic reminder checks
            setInterval(checkReminders, 60000); // Check every minute
            
            // Set up automatic export with smart scheduling
            setupSmartExportScheduling();
            
            // Check for pending exports from previous sessions
            checkPendingExport();
            
            // Set up offline detection
            setupOfflineDetection();
            
            // Register service worker
            if ('serviceWorker' in navigator) {
                navigator.serviceWorker.register('sw.js').catch(console.error);
            }
        });

        // Task management functions
        function addTask() {
            const title = document.getElementById('taskTitle').value.trim();
            if (!title) {
                showNotification('Please enter a task title', 'error');
                return;
            }

            const description = document.getElementById('taskDescription').value.trim();
            const customer = document.getElementById('customerName').value.trim();
            
            let reminderDateTime = '';
            if (selectedReminderOption === 'custom') {
                reminderDateTime = document.getElementById('reminderDateTime').value;
            } else if (selectedReminderOption === '3h') {
                const now = new Date();
                now.setHours(now.getHours() + 3);
                reminderDateTime = now.toISOString().slice(0, 16);
            } else if (selectedReminderOption === '1d') {
                const now = new Date();
                now.setDate(now.getDate() + 1);
                reminderDateTime = now.toISOString().slice(0, 16);
            }

            // Parse sub-tasks from description
            const subTasks = parseSubTasks(description);
            
            const task = {
                id: Date.now().toString(),
                title: title,
                description: description,
                customer: customer,
                reminderDateTime: reminderDateTime,
                completed: false,
                createdAt: new Date().toISOString(),
                completedAt: null,
                subTasks: subTasks
            };

            tasks.push(task);
            if (customer) customers.add(customer);
            
            saveTasks();
            updateStats();
            updateCustomerList();
            updateCustomerSuggestions();
            
            // Only filter tasks if not on clients tab
            if (currentTab === 'clients') {
                renderClients();
            } else {
                filterTasks();
            }
            
            // Clear form
            clearTaskForm();
            
            showNotification('Task added successfully!', 'success');
        }

        function clearTaskForm() {
            document.getElementById('taskTitle').value = '';
            document.getElementById('taskDescription').value = '';
            document.getElementById('customerName').value = '';
            document.getElementById('reminderDateTime').value = '';
            hideCustomerSuggestions();
            
            // Reset reminder options
            setReminderOption('none');
        }

        function handleEnterKey(event) {
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                addTask();
            }
        }

        // Sub-task functions
        function parseSubTasks(description) {
            if (!description) return [];
            
            const lines = description.split('\n');
            const subTasks = [];
            
            lines.forEach((line, index) => {
                const trimmed = line.trim();
                if (trimmed.startsWith('- ')) {
                    subTasks.push({
                        id: `${Date.now()}_${index}`,
                        text: trimmed.substring(2).trim(),
                        completed: false
                    });
                }
            });
            
            return subTasks;
        }

        function toggleSubTask(taskId, subTaskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task && task.subTasks) {
                const subTask = task.subTasks.find(st => st.id === subTaskId);
                if (subTask) {
                    subTask.completed = !subTask.completed;
                    saveTasks();
                    
                    // Update only the subtask display and progress without reloading entire container
                    updateSubTaskDisplay(taskId, subTaskId);
                }
            }
        }

        function updateSubTaskDisplay(taskId, subTaskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;

            // Find the task container
            const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
            if (!taskElement) return;

            // Update the specific subtask text styling
            const subTaskCheckbox = taskElement.querySelector(`input[onchange*="${subTaskId}"]`);
            if (subTaskCheckbox) {
                const subTaskText = subTaskCheckbox.nextElementSibling;
                const subTask = task.subTasks.find(st => st.id === subTaskId);
                
                if (subTask && subTaskText) {
                    if (subTask.completed) {
                        subTaskText.classList.add('completed');
                        subTaskCheckbox.checked = true;
                    } else {
                        subTaskText.classList.remove('completed');
                        subTaskCheckbox.checked = false;
                    }
                }
            }

            // Update progress display
            const progressElement = taskElement.querySelector('.sub-task-progress');
            if (progressElement) {
                const progress = getSubTaskProgress(task);
                if (progress) {
                    progressElement.innerHTML = `<i class="fas fa-tasks"></i> ${progress.completed}/${progress.total} completed (${progress.percentage}%)`;
                }
            }
        }

        function showTaskInfo(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            const modal = document.getElementById('taskInfoModal');
            const content = document.getElementById('taskInfoContent');
            
            const progressInfo = getSubTaskProgress(task);
            const progressText = progressInfo ? 
                `${progressInfo.completed}/${progressInfo.total} sub-tasks completed (${progressInfo.percentage}%)` : 
                'No sub-tasks';
            
            content.innerHTML = `
                <div class="task-info-item">
                    <div class="task-info-label">Created</div>
                    <div class="task-info-value">${formatDateTime(task.createdAt)}</div>
                </div>
                
                ${task.completedAt ? `
                    <div class="task-info-item">
                        <div class="task-info-label">Completed</div>
                        <div class="task-info-value">${formatDateTime(task.completedAt)}</div>
                    </div>
                ` : ''}
                
                ${task.reminderDateTime ? `
                    <div class="task-info-item">
                        <div class="task-info-label">Reminder</div>
                        <div class="task-info-value">${formatDateTime(task.reminderDateTime)}</div>
                    </div>
                ` : ''}
                
                ${task.customer ? `
                    <div class="task-info-item">
                        <div class="task-info-label">Customer/Client</div>
                        <div class="task-info-value">${escapeHtml(task.customer)}</div>
                    </div>
                ` : ''}
                
                <div class="task-info-item">
                    <div class="task-info-label">Sub-tasks Progress</div>
                    <div class="task-info-value">${progressText}</div>
                </div>
                
                <div class="task-info-item">
                    <div class="task-info-label">Task ID</div>
                    <div class="task-info-value" style="font-family: monospace; font-size: 0.9rem;">${task.id}</div>
                </div>
            `;
            
            modal.classList.add('show');
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeTaskInfo();
                }
            };
        }

        function closeTaskInfo() {
            const modal = document.getElementById('taskInfoModal');
            modal.classList.remove('show');
        }

        function showPrivacyInfo() {
            const modal = document.getElementById('privacyInfoModal');
            modal.classList.add('show');
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closePrivacyInfo();
                }
            };
        }

        function closePrivacyInfo() {
            const modal = document.getElementById('privacyInfoModal');
            modal.classList.remove('show');
        }

        function updateSingleTaskDisplay(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            // Find the task element in the DOM
            const taskElements = document.querySelectorAll('.task-item');
            let targetElement = null;
            
            taskElements.forEach(element => {
                const completeButton = element.querySelector('button[onclick*="completeTask"]');
                const deleteButton = element.querySelector('button[onclick*="deleteTask"]');
                if (completeButton && completeButton.onclick.toString().includes(taskId)) {
                    targetElement = element;
                }
            });
            
            if (targetElement) {
                // Create new HTML for this task
                const newHTML = createTaskHTML(task);
                
                // Create a temporary div to hold the new content
                const tempDiv = document.createElement('div');
                tempDiv.innerHTML = newHTML;
                const newTaskElement = tempDiv.firstElementChild;
                
                // Replace the old element with the new one
                targetElement.parentNode.replaceChild(newTaskElement, targetElement);
                
                // Add the fade-in animation to the new element
                newTaskElement.classList.add('slide-in');
            }
        }

        function getSubTaskProgress(task) {
            if (!task.subTasks || task.subTasks.length === 0) return null;
            
            const completed = task.subTasks.filter(st => st.completed).length;
            const total = task.subTasks.length;
            const percentage = Math.round((completed / total) * 100);
            
            return {
                completed,
                total,
                percentage
            };
        }

        function setReminderOption(option) {
            selectedReminderOption = option;
            
            const reminderOptions = document.querySelector('.reminder-options');
            const customDateTime = document.getElementById('customDateTime');
            
            // Update button states
            document.querySelectorAll('.reminder-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate the clicked button
            const buttons = document.querySelectorAll('.reminder-btn');
            const options = ['3h', '1d', 'custom', 'none'];
            const index = options.indexOf(option);
            
            if (index !== -1) {
                buttons[index].classList.add('active');
            }
            
            // Handle animations for custom option
            if (option === 'custom') {
                // Set current date and time as default
                const now = new Date();
                const currentDateTime = now.toISOString().slice(0, 16);
                document.getElementById('reminderDateTime').value = currentDateTime;
                
                // Hide quick options with animation
                reminderOptions.classList.add('hide-quick');
                
                // Show custom datetime with delay for smooth transition
                setTimeout(() => {
                    customDateTime.classList.add('show');
                    setTimeout(() => {
                        document.getElementById('reminderDateTime').focus();
                    }, 200);
                }, 300);
            } else {
                // Hide custom datetime
                customDateTime.classList.remove('show');
                
                // Show quick options
                reminderOptions.classList.remove('hide-quick');
            }
        }

        function completeTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                // Find the task element and add completion animation
                const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskElement) {
                    taskElement.classList.add('task-completing');
                    
                    // Wait for animation to complete before updating data
                    setTimeout(() => {
                        task.completed = true;
                        task.completedAt = new Date().toISOString();
                        saveTasks();
                        updateStats();
                        updateCustomerList();
                        filterTasksWithoutAnimation();
                        showNotification('Task completed!', 'success');
                    }, 600); // Match animation duration
                } else {
                    // Fallback if element not found
                    task.completed = true;
                    task.completedAt = new Date().toISOString();
                    saveTasks();
                    updateStats();
                    updateCustomerList();
                    filterTasks();
                    showNotification('Task completed!', 'success');
                }
            }
        }

        function uncompleteTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (task) {
                task.completed = false;
                task.completedAt = null;
                saveTasks();
                updateStats();
                updateCustomerList();
                filterTasks();
                showNotification('Task marked as pending', 'success');
            }
        }

        function deleteTask(taskId) {
            if (confirm('Are you sure you want to delete this task?')) {
                tasks = tasks.filter(t => t.id !== taskId);
                saveTasks();
                updateStats();
                updateCustomerList();
                filterTasks();
                showNotification('Task deleted', 'success');
            }
        }

        function moveTaskToTop(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task || task.completed) return;
            
            // Get all pending tasks for current filter
            const filteredTasks = getFilteredTasks().filter(t => !t.completed);
            
            // Assign custom order to all tasks, with the selected task at position 0
            filteredTasks.forEach((t, index) => {
                if (t.id === taskId) {
                    t.customOrder = 0;
                } else {
                    // Shift other tasks down
                    const currentOrder = t.customOrder !== undefined ? t.customOrder : index;
                    t.customOrder = currentOrder >= 0 ? currentOrder + 1 : index + 1;
                }
            });
            
            saveTasks();
            filterTasks();
            showNotification('Task moved to top', 'success');
        }

        // Clients actions
        function moveClientToTop(key) {
            const clients = getClientsArray();
            const idx = clients.findIndex(c => c.key === key);
            if (idx === -1) return;
            // Reassign order so this client becomes first
            clients.forEach((c, i) => {
                clientsMeta[c.key] = clientsMeta[c.key] || {};
                clientsMeta[c.key].order = i + 1;
            });
            clientsMeta[key].order = 0;
            saveClientsMeta();
            if (currentTab === 'clients') renderClients();
        }

        function showClientInfo(key) {
            const client = getClientsArray().find(c => c.key === key);
            if (!client) return;
            const modal = document.getElementById('clientInfoModal');
            const content = document.getElementById('clientInfoContent');
            const meta = clientsMeta[key] || {};
            content.innerHTML = `
                <div class="task-info-item">
                    <div class="task-info-label">Client</div>
                    <div class="task-info-value">${escapeHtml(client.name)}</div>
                </div>
                <div class="task-info-item">
                    <div class="task-info-label">Assigned</div>
                    <div class="task-info-value">${meta.assigned ? 'Yes' : 'No'}</div>
                </div>
                <div class="task-info-item">
                    <div class="task-info-label">Notes</div>
                    <div class="task-info-value">${meta.notes ? escapeHtml(meta.notes) : '<span style="color: var(--light-text)">No notes</span>'}</div>
                </div>
                <div class="task-info-item">
                    <div class="task-info-label">Labels & Workflows</div>
                    <div class="task-info-value">
                        ${meta.labelIds && meta.labelIds.length > 0 ? `
                            <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 5px;">
                                ${meta.labelIds.map(labelId => {
                                    const simpleLabel = simpleLabels.find(l => l.id === labelId);
                                    const workflowLabel = clientLabels.find(l => l.id === labelId);
                                    
                                    if (simpleLabel) {
                                        return `
                                            <span style="display: inline-flex; align-items: center; padding: 4px 10px; background: var(--secondary-color); color: var(--white); border-radius: 12px; font-size: 0.85rem; font-weight: 500;">
                                                <i class="fas fa-tag" style="font-size: 0.7rem; margin-right: 4px;"></i>
                                                ${escapeHtml(simpleLabel.name)}
                                            </span>
                                        `;
                                    } else if (workflowLabel) {
                                        return `
                                            <span style="display: inline-flex; align-items: center; padding: 4px 10px; background: #764ba2; color: var(--white); border-radius: 12px; font-size: 0.85rem; font-weight: 500;">
                                                <i class="fas fa-project-diagram" style="font-size: 0.7rem; margin-right: 4px;"></i>
                                                ${escapeHtml(workflowLabel.name)}
                                            </span>
                                        `;
                                    }
                                    return '';
                                }).join('')}
                            </div>
                        ` : '<span style="color: var(--light-text)">No labels or workflows</span>'}
                    </div>
                </div>
                ${meta.currentPhase ? `
                    <div class="task-info-item">
                        <div class="task-info-label">Current Phase</div>
                        <div class="task-info-value">
                            ${(() => {
                                const label = clientLabels.find(l => l.id === meta.currentPhase.labelId);
                                if (!label) return '<span style="color: var(--light-text)">Unknown</span>';
                                return `<span style="font-weight: 600; color: var(--secondary-color);">${escapeHtml(meta.currentPhase.phasePath ? meta.currentPhase.phasePath.join(' → ') : 'Unknown')}</span>`;
                            })()}
                        </div>
                    </div>
                ` : ''}
            `;
            modal.classList.add('show');
        }

        function closeClientInfo() {
            document.getElementById('clientInfoModal').classList.remove('show');
        }

        let currentEditingClientKey = null;
        function editClient(key) {
            const client = getClientsArray().find(c => c.key === key);
            if (!client) return;
            currentEditingClientKey = key;
            const meta = clientsMeta[key] || {};
            document.getElementById('editClientName').value = client.name;
            document.getElementById('editClientAssigned').checked = !!meta.assigned;
            const assignedText = document.getElementById('editClientAssignedText');
            const assignedBtn = document.getElementById('editClientAssignedBtn');
            if (assignedText && assignedBtn) {
                assignedText.textContent = meta.assigned ? 'Assigned to me' : 'Not assigned';
                assignedBtn.title = meta.assigned ? 'Unassign from me' : 'Assign to me';
                assignedBtn.innerHTML = meta.assigned ? '<i class="fas fa-user-minus"></i>' : '<i class="fas fa-user-check"></i>';
            }
            document.getElementById('editClientNotes').value = meta.notes || '';
            document.getElementById('editClientModal').classList.add('show');
        }

        function closeEditClient() {
            currentEditingClientKey = null;
            document.getElementById('editClientModal').classList.remove('show');
        }

        function saveClientEdit() {
            if (!currentEditingClientKey) return;
            const oldKey = currentEditingClientKey;
            const newName = document.getElementById('editClientName').value.trim();
            const assigned = document.getElementById('editClientAssigned').checked;
            const notes = document.getElementById('editClientNotes').value.trim();
            if (!newName) {
                showNotification('Please enter a client name', 'error');
                return;
            }
            const newKey = getClientKey(newName);
            const meta = clientsMeta[oldKey] || {};
            // If name changed and key differs, remap meta and tasks
            if (newKey !== oldKey) {
                clientsMeta[newKey] = { ...meta };
                delete clientsMeta[oldKey];
                // Update tasks referencing old name
                tasks.forEach(t => {
                    if (t.customer === oldKey) t.customer = newKey;
                });
            }
            clientsMeta[newKey] = clientsMeta[newKey] || {};
            clientsMeta[newKey].assigned = assigned;
            clientsMeta[newKey].notes = notes;
            // Persist meta immediately so assignment/notes survive reloads without relying solely on saveTasks
            saveClientsMeta();
            persistLog('clientsMeta.saveClientEdit', { key: newKey, assigned, notesLength: notes.length });
            saveTasks();
            updateCustomerList();
            filterTasks();
            if (currentTab === 'clients') renderClients();
            closeEditClient();
            showNotification('Client updated successfully!', 'success');
        }

        function toggleEditClientAssigned() {
            const checkbox = document.getElementById('editClientAssigned');
            const assignedText = document.getElementById('editClientAssignedText');
            const assignedBtn = document.getElementById('editClientAssignedBtn');
            if (!checkbox || !assignedText || !assignedBtn) return;
            checkbox.checked = !checkbox.checked;
            const isAssigned = checkbox.checked;
            assignedText.textContent = isAssigned ? 'Assigned to me' : 'Not assigned';
            assignedBtn.title = isAssigned ? 'Unassign from me' : 'Assign to me';
            assignedBtn.innerHTML = isAssigned ? '<i class=\"fas fa-user-minus\"></i>' : '<i class=\"fas fa-user-check\"></i>';
        }

        function refreshQuickAddLabelList() {
            if (!currentLabelClientKey) return;
            const decodedKey = currentLabelClientKey.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
            const meta = clientsMeta[decodedKey] || {};
            const clientLabelIds = meta.labelIds || [];
            
            const labelsList = document.getElementById('quickAddLabelList');
            labelsList.innerHTML = '';
            
            if (simpleLabels.length === 0) {
                labelsList.innerHTML = '<div class="labels-modal-empty">No labels available. Create one below.</div>';
            } else {
                simpleLabels.forEach(label => {
                    const isSelected = clientLabelIds.includes(label.id);
                    const labelElement = document.createElement('div');
                    labelElement.className = `label-card${isSelected ? ' selected' : ''}`;
                    labelElement.style.cursor = 'pointer';
                    labelElement.innerHTML = `
                        <div class="label-card-left">
                            <div class="label-badge">
                                <i class="fas fa-tag"></i>
                            </div>
                            <div>
                                <div class="label-card-title">${escapeHtml(label.name)}</div>
                                ${isSelected ? '<div class="label-card-meta"><span class="label-selected-pill"><i class="fas fa-check"></i> Selected</span></div>' : ''}
                            </div>
                        </div>
                    `;
                    labelElement.onclick = () => {
                        toggleClientSimpleLabel(decodedKey, label.id);
                        refreshQuickAddLabelList(); // Refresh to show updated state
                    };
                    labelsList.appendChild(labelElement);
                });
            }
        }

        function quickAddLabel(key) {
            // Decode HTML entities if present (from onclick handler)
            const decodedKey = key.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
            const client = getClientsArray().find(c => c.key === decodedKey);
            if (!client) return;
            currentLabelClientKey = key; // Store the original encoded key
            refreshQuickAddLabelList();
            document.getElementById('quickAddLabelModal').classList.add('show');
        }

        function createNewSimpleLabel() {
            const labelName = prompt('Enter label name:');
            if (!labelName || !labelName.trim()) return;
            
            const trimmedName = labelName.trim();
            
            // Check for duplicate names
            if (simpleLabels.some(l => l.name === trimmedName)) {
                showNotification('A label with this name already exists', 'error');
                return;
            }
            
            const newLabel = {
                id: `simple_label_${Date.now()}`,
                name: trimmedName
            };
            
            simpleLabels.push(newLabel);
            saveSimpleLabels();
            persistLog('simpleLabels.create', { labelName: trimmedName });
            
            // Refresh the quick add modal list
            refreshQuickAddLabelList();
            
            showNotification(`Label "${trimmedName}" created successfully!`, 'success');
        }

        function toggleClientSimpleLabel(key, labelId) {
            // Decode HTML entities if present (from onclick handler)
            const decodedKey = key.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
            clientsMeta[decodedKey] = clientsMeta[decodedKey] || {};
            clientsMeta[decodedKey].labelIds = clientsMeta[decodedKey].labelIds || [];
            const labelIds = clientsMeta[decodedKey].labelIds;
            const index = labelIds.indexOf(labelId);
            
            if (index > -1) {
                labelIds.splice(index, 1);
            } else {
                labelIds.push(labelId);
            }
            
            saveClientsMeta();
            persistLog('simpleLabels.toggle', { key: decodedKey, labelId, labelIds: clientsMeta[decodedKey].labelIds });
            
            // Refresh the label list in the modal
            refreshQuickAddLabelList();
            
            // Refresh client display
            if (currentTab === 'clients') renderClients();
            
            const label = simpleLabels.find(l => l.id === labelId);
            showNotification(`Label "${label ? label.name : labelId}" ${index > -1 ? 'removed' : 'added'}`, 'success');
        }

        function saveSimpleLabels() {
            try {
                localStorage.setItem('legalSimpleLabels', JSON.stringify(simpleLabels));
                persistLog('simpleLabels.save', { count: simpleLabels.length });
            } catch (e) {
                console.error('Error saving simple labels', e);
                persistLog('simpleLabels.save.error', { error: String(e) });
            }
        }

        function loadSimpleLabels() {
            try {
                const saved = localStorage.getItem('legalSimpleLabels');
                if (saved) {
                    const parsed = JSON.parse(saved);
                    simpleLabels = Array.isArray(parsed) ? parsed : [];
                } else {
                    simpleLabels = [];
                }
                persistLog('simpleLabels.load', { count: simpleLabels.length });
            } catch (e) {
                console.error('Error loading simple labels', e);
                simpleLabels = [];
                persistLog('simpleLabels.load.error', { error: String(e) });
            }
        }

        function closeQuickAddLabel() {
            document.getElementById('quickAddLabelModal').classList.remove('show');
        }

        function showClientWorkflows(key) {
            // Decode HTML entities if present (from onclick handler)
            const decodedKey = key.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
            const client = getClientsArray().find(c => c.key === decodedKey);
            if (!client) return;
            currentLabelClientKey = decodedKey;
            const meta = clientsMeta[decodedKey] || {};
            const clientLabelIds = meta.labelIds || [];
            
            // Render workflows list
            const labelsList = document.getElementById('labelsList');
            labelsList.innerHTML = '';
            labelsList.classList.add('labels-modal-list');
            
            if (clientLabels.length === 0) {
                labelsList.innerHTML = '<div class="labels-modal-empty">No workflows available. Create one below.</div>';
            } else {
                clientLabels.forEach(label => {
                    const isSelected = clientLabelIds.includes(label.id);
                    const labelElement = document.createElement('div');
                    labelElement.className = `label-card${isSelected ? ' selected' : ''}`;
                    const phasesCount = label.phases ? label.phases.length : 0;
                    labelElement.innerHTML = `
                        <div class="label-card-left">
                            <div class="label-badge">
                                <i class="fas fa-project-diagram"></i>
                            </div>
                            <div>
                                <div class="label-card-title">${escapeHtml(label.name)}</div>
                                <div class="label-card-meta">
                                    <span>${phasesCount} phase${phasesCount !== 1 ? 's' : ''}</span>
                                    ${isSelected ? '<span class="label-selected-pill"><i class="fas fa-check"></i> Selected</span>' : ''}
                                </div>
                            </div>
                        </div>
                        <div class="label-card-actions">
                            <button class="label-edit-btn" onclick="event.stopPropagation(); editExistingLabel('${label.id}')">
                                <i class="fas fa-pen"></i> Edit
                            </button>
                        </div>
                    `;
                    labelElement.onclick = () => toggleClientLabel(decodedKey, label.id);
                    labelsList.appendChild(labelElement);
                });
            }
            
            document.getElementById('clientLabelsModal').classList.add('show');
        }

        function closeClientWorkflows() {
            currentLabelClientKey = null;
            document.getElementById('clientLabelsModal').classList.remove('show');
        }

        function toggleClientLabel(key, labelId) {
            // Decode HTML entities if present (from onclick handler)
            const decodedKey = key.replace(/&#39;/g, "'").replace(/&quot;/g, '"');
            clientsMeta[decodedKey] = clientsMeta[decodedKey] || {};
            clientsMeta[decodedKey].labelIds = clientsMeta[decodedKey].labelIds || [];
            const labelIds = clientsMeta[decodedKey].labelIds;
            const index = labelIds.indexOf(labelId);
            
            if (index > -1) {
                labelIds.splice(index, 1);
                // Also clear current phase if it was for this label
                if (clientsMeta[decodedKey].currentPhase && clientsMeta[decodedKey].currentPhase.labelId === labelId) {
                    delete clientsMeta[decodedKey].currentPhase;
                }
            } else {
                labelIds.push(labelId);
                // Auto-assign first phase when label is added
                const label = clientLabels.find(l => l.id === labelId);
                if (label && label.phases && label.phases.length > 0) {
                    const getFirstPhase = (phases, path = []) => {
                        if (phases.length === 0) return null;
                        const firstPhase = phases[0];
                        const currentPath = [...path, firstPhase.name];
                        return {
                            id: firstPhase.id,
                            name: firstPhase.name,
                            path: currentPath
                        };
                    };
                    const firstPhase = getFirstPhase(label.phases);
                    if (firstPhase) {
                        clientsMeta[decodedKey].currentPhase = {
                            labelId: labelId,
                            phaseId: firstPhase.id,
                            phasePath: firstPhase.path
                        };
                    }
                }
            }
            
            saveClientsMeta();
            persistLog('clientLabels.toggle', { key: decodedKey, labelId, labelIds: clientsMeta[decodedKey].labelIds });
            
            // Refresh the workflows modal if open
            if (currentLabelClientKey === decodedKey) {
                showClientWorkflows(decodedKey);
            }
            
            // Refresh client display
            if (currentTab === 'clients') renderClients();
            
            const label = clientLabels.find(l => l.id === labelId);
            showNotification(`Label "${label ? label.name : labelId}" ${index > -1 ? 'removed' : 'added'}`, 'success');
        }

        function openCreateLabelModal() {
            editingLabelId = null;
            phaseCounter = 0;
            document.getElementById('labelNameInput').value = '';
            document.querySelector('#createLabelModal h3').innerHTML = '<i class="fas fa-plus-circle"></i> Create Workflow';
            initLabelBuilder([]);
            document.getElementById('createLabelModal').classList.add('show');
        }

        function editExistingLabel(labelId) {
            const label = clientLabels.find(l => l.id === labelId);
            if (!label) return;
            
            editingLabelId = labelId;
            phaseCounter = 0;
            document.getElementById('labelNameInput').value = label.name;
            document.querySelector('#createLabelModal h3').innerHTML = '<i class="fas fa-edit"></i> Edit Workflow';
            initLabelBuilder(label.phases || []);
            document.getElementById('createLabelModal').classList.add('show');
        }

        function closeCreateLabelModal() {
            editingLabelId = null;
            initLabelBuilder([]);
            document.getElementById('createLabelModal').classList.remove('show');
        }

        function saveNewLabel() {
            const labelName = document.getElementById('labelNameInput').value.trim();
            if (!labelName) {
                showNotification('Please enter a workflow name', 'error');
                return;
            }

            // Check for duplicate names
            if (clientLabels.some(l => l.name === labelName && l.id !== editingLabelId)) {
                showNotification('A workflow with this name already exists', 'error');
                return;
            }

            const phaseTree = normalizePhaseTree(labelBuilderPhases);
            if (phaseTree.length === 0) {
                showNotification('Please add at least one phase', 'error');
                return;
            }
            labelBuilderPhases = clonePhaseTree(phaseTree);

            if (editingLabelId) {
                // Update existing label
                const labelIndex = clientLabels.findIndex(l => l.id === editingLabelId);
                if (labelIndex !== -1) {
                    clientLabels[labelIndex] = {
                        ...clientLabels[labelIndex],
                        name: labelName,
                        phases: phaseTree
                    };
                }
            } else {
                // Create new label
                const newLabel = {
                    id: `label_${Date.now()}`,
                    name: labelName,
                    phases: phaseTree
                };
                clientLabels.push(newLabel);
            }

            saveClientLabels();
            persistLog('clientLabels.save', { labelName, phasesCount: phaseTree.length });
            
            closeCreateLabelModal();
            
            // Refresh workflows modal if open
            if (currentLabelClientKey) {
                showClientWorkflows(currentLabelClientKey);
            }
            
            showNotification(`Workflow "${labelName}" ${editingLabelId ? 'updated' : 'created'} successfully!`, 'success');
        }

        function initLabelBuilder(phases) {
            labelBuilderPhases = clonePhaseTree(phases);
            selectedBuilderPhaseId = labelBuilderPhases[0] ? labelBuilderPhases[0].id : null;
            builderFocusPhaseId = null;
            builderFocusTaskKey = null;
            builderExpandedPhaseIds = new Set();
            builderConfirmedTasks.clear(); // Clear confirmed tasks when initializing builder
            renderLabelBuilderCanvas();
        }

        function clonePhaseTree(phases) {
            return JSON.parse(JSON.stringify(phases || []));
        }

        function renderLabelBuilderCanvas() {
            const canvas = document.getElementById('labelBuilderCanvas');
            if (!canvas) return;
            if (!labelBuilderPhases.length) {
                canvas.innerHTML = `
                    <div class="label-builder-empty">
                        Tap the <strong>+ Add phase</strong> bubble to start mapping this proceeding.
                        <div style="margin-top: 12px;">
                            <button type="button" class="builder-add-chip" onclick="handleAddPhase()">
                                <i class="fas fa-plus"></i> Add phase
                            </button>
                        </div>
                    </div>
                `;
                return;
            }
            const columns = labelBuilderPhases.map((phase, index) => renderBuilderColumn(phase, index)).join('');
            canvas.innerHTML = `
                <div class="builder-scroll">
                    ${columns}
                    <button type="button" class="builder-add-chip" onclick="handleAddPhase()">
                        <i class="fas fa-plus"></i> Add phase
                    </button>
                </div>
            `;
            focusBuilderPhaseInput();
            focusBuilderTaskInput();
        }

        function renderBuilderColumn(phase, index) {
            const column = `
                <div class="timeline-column builder-column">
                    ${renderBuilderPhaseBlock(phase, false)}
                    ${renderBuilderSubTrack(phase.subPhases || [], phase.id, 1)}
                </div>
            `;
            const connector = index < labelBuilderPhases.length - 1 ? '<div class="timeline-column-connector is-future"></div>' : '';
            return column + connector;
        }

        function renderBuilderSubTrack(subPhases, parentId, level = 1) {
            const children = (subPhases || []).map(subPhase => `
                <div class="builder-column" style="min-width: 140px;">
                    ${renderBuilderPhaseBlock(subPhase, true)}
                    ${renderBuilderSubTrack(subPhase.subPhases || [], subPhase.id, level + 1)}
                </div>
            `).join('');
            return `
                <div class="builder-sub-track level-${level}">
                    ${children}
                    <button type="button" class="builder-add-chip small" onclick="handleAddSubPhase('${parentId}')">
                        <i class="fas fa-plus"></i> Sub-phase
                    </button>
                </div>
            `;
        }

        function renderBuilderPhaseBlock(phase, isSub) {
            return `
                <div class="builder-phase-block" data-phase-block="${phase.id}">
                    ${renderBuilderPhaseChip(phase, isSub)}
                    ${renderBuilderTasksContainer(phase)}
                </div>
            `;
        }

        function renderBuilderPhaseChip(phase, isSub) {
            const isActive = selectedBuilderPhaseId === phase.id;
            const isExpanded = builderExpandedPhaseIds.has(phase.id);
            return `
                <div class="builder-phase-chip ${isSub ? 'is-sub' : ''} ${isActive ? 'is-active' : ''} ${isExpanded ? 'expanded' : ''}" data-phase-chip="${phase.id}" onclick="handleBuilderChipClick('${phase.id}')">
                    <input type="text" class="builder-phase-input" data-phase-input="${phase.id}" value="${escapeHtml(phase.name || '')}" placeholder="${isSub ? 'Sub-phase name' : 'Phase name'}" onclick="event.stopPropagation();" oninput="handleBuilderPhaseNameInput('${phase.id}', event)" onfocus="handleBuilderInputFocus('${phase.id}')">
                    <div class="builder-chip-actions">
                        <button type="button" class="builder-template-btn ${isExpanded ? 'is-open' : ''}" onclick="event.stopPropagation(); toggleBuilderPhaseExpansion('${phase.id}')">
                            <i class="fas fa-tasks"></i>
                            <i class="fas fa-chevron-down builder-template-chevron"></i>
                        </button>
                        <button type="button" class="delete" onclick="event.stopPropagation(); handleDeletePhase('${phase.id}')">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                </div>
            `;
        }

        function renderBuilderTasksContainer(phase) {
            const isExpanded = builderExpandedPhaseIds.has(phase.id);
            const tasks = phase.tasks || [];
            const displayStyle = isExpanded ? 'block' : 'none';
            const maxHeightStyle = isExpanded ? 'none' : '0';
            const opacityStyle = isExpanded ? '1' : '0';
            return `
                <div class="builder-phase-tasks ${isExpanded ? 'show' : ''}" data-phase-tasks="${phase.id}" style="display:${displayStyle}; max-height:${maxHeightStyle}; opacity:${opacityStyle};">
                    <div class="builder-task-list">
                        ${tasks.length ? tasks.map((task, index) => renderBuilderTaskRow(phase.id, task, index)).join('') : '<div class="builder-empty-tasks">No template tasks yet.</div>'}
                    </div>
                    <button type="button" class="builder-add-task-btn" onclick="addBuilderTask('${phase.id}')">
                        <i class="fas fa-tasks"></i> Add template task
                    </button>
                </div>
            `;
        }

        function renderBuilderTaskRow(phaseId, task, index) {
            const rowKey = `${phaseId}:${index}`;
            const shouldFlash = builderConfirmFlashKey === rowKey;
            if (shouldFlash) builderConfirmFlashKey = null;
            const isConfirmed = builderConfirmedTasks.has(rowKey);
            const trimmedTask = (task || '').trim();
            const isEmpty = !trimmedTask;
            
            return `
                <div class="builder-task-row${shouldFlash ? ' confirmed' : ''}">
                    <input type="text" 
                           data-builder-task-input="${phaseId}:${index}" 
                           value="${escapeHtml(task)}" 
                           placeholder="Task title" 
                           ${isConfirmed && !isEmpty ? 'readonly' : ''}
                           oninput="handleBuilderTaskInput('${phaseId}', ${index}, event)"
                           style="${isConfirmed && !isEmpty ? 'background: #f6f8fb; cursor: not-allowed;' : ''}">
                    ${isConfirmed && !isEmpty ? `
                        <button type="button" class="builder-task-edit" onclick="editBuilderTask('${phaseId}', ${index})" title="Edit task">
                            <i class="fas fa-edit"></i>
                        </button>
                    ` : `
                        <button type="button" class="builder-task-confirm" onclick="confirmBuilderTask('${phaseId}', ${index})" title="Save task">
                            <i class="fas fa-check"></i>
                        </button>
                    `}
                    <button type="button" class="builder-task-delete" onclick="removeBuilderTask('${phaseId}', ${index})" title="Remove template">
                        <i class="fas fa-trash"></i>
                    </button>
                </div>
            `;
        }

        function handleBuilderChipClick(phaseId) {
            setSelectedBuilderPhase(phaseId, true);
        }

        function handleBuilderInputFocus(phaseId) {
            setSelectedBuilderPhase(phaseId, true);
        }

        function handleAddPhase() {
            const newPhase = createBlankPhase();
            labelBuilderPhases.push(newPhase);
            selectedBuilderPhaseId = newPhase.id;
            builderFocusPhaseId = newPhase.id;
            builderExpandedPhaseIds.add(newPhase.id);
            renderLabelBuilderCanvas();
        }

        function handleAddSubPhase(parentId) {
            const parentRef = findPhaseRef(parentId);
            if (!parentRef) return;
            parentRef.phase.subPhases = parentRef.phase.subPhases || [];
            const newPhase = createBlankPhase();
            parentRef.phase.subPhases.push(newPhase);
            selectedBuilderPhaseId = newPhase.id;
            builderFocusPhaseId = newPhase.id;
            builderExpandedPhaseIds.add(newPhase.id);
            renderLabelBuilderCanvas();
        }

        function createBlankPhase() {
            return {
                id: `phase_${Date.now()}_${phaseCounter++}`,
                name: '',
                tasks: [],
                subPhases: []
            };
        }

        function findPhaseRef(phaseId, phases = labelBuilderPhases, parentPhase = null) {
            for (let i = 0; i < phases.length; i++) {
                const phase = phases[i];
                if (phase.id === phaseId) {
                    return { phase, collection: phases, index: i, parent: parentPhase };
                }
                if (phase.subPhases && phase.subPhases.length > 0) {
                    const nested = findPhaseRef(phaseId, phase.subPhases, phase);
                    if (nested) return nested;
                }
            }
            return null;
        }

        function handleDeletePhase(phaseId) {
            const ref = findPhaseRef(phaseId);
            if (!ref) return;
            ref.collection.splice(ref.index, 1);
            builderExpandedPhaseIds.delete(phaseId);
            ensureBuilderSelectionValidity();
            renderLabelBuilderCanvas();
        }

        function ensureBuilderSelectionValidity() {
            if (selectedBuilderPhaseId && !findPhaseRef(selectedBuilderPhaseId)) {
                selectedBuilderPhaseId = labelBuilderPhases[0] ? labelBuilderPhases[0].id : null;
            }
            builderExpandedPhaseIds.forEach(id => {
                if (!findPhaseRef(id)) {
                    builderExpandedPhaseIds.delete(id);
                }
            });
        }

        function setSelectedBuilderPhase(phaseId, focusInput = false) {
            selectedBuilderPhaseId = phaseId;
            if (focusInput) {
                builderFocusPhaseId = phaseId;
            }
            renderLabelBuilderCanvas();
        }

        function handleBuilderPhaseNameInput(phaseId, event) {
            const ref = findPhaseRef(phaseId);
            if (!ref) return;
            ref.phase.name = event.target.value;
        }

        function focusBuilderPhaseInput() {
            if (!builderFocusPhaseId) return;
            const canvas = document.getElementById('labelBuilderCanvas');
            if (!canvas) return;
            const target = canvas.querySelector(`[data-phase-input="${builderFocusPhaseId}"]`);
            if (target) {
                target.focus();
                target.select();
            }
            builderFocusPhaseId = null;
        }

        function focusBuilderTaskInput() {
            if (!builderFocusTaskKey) return;
            const canvas = document.getElementById('labelBuilderCanvas');
            if (!canvas) return;
            const taskInput = canvas.querySelector(`[data-builder-task-input="${builderFocusTaskKey}"]`);
            if (taskInput) {
                taskInput.focus();
                taskInput.select();
            }
            builderFocusTaskKey = null;
        }

        function toggleBuilderPhaseExpansion(phaseId) {
            const container = document.querySelector(`[data-phase-tasks="${phaseId}"]`);
            const chip = document.querySelector(`[data-phase-chip="${phaseId}"]`);
            const templateBtn = chip ? chip.querySelector('.builder-template-btn') : null;
            if (!container || !chip) return;
            const isExpanded = builderExpandedPhaseIds.has(phaseId);
            if (isExpanded) {
                builderExpandedPhaseIds.delete(phaseId);
                collapseBuilderTasks(container, chip, templateBtn);
            } else {
                builderExpandedPhaseIds.add(phaseId);
                expandBuilderTasks(container, chip, templateBtn);
            }
        }

        function expandBuilderTasks(container, chip, templateBtn) {
            container.style.display = 'block';
            container.style.overflow = 'hidden';
            container.style.maxHeight = '0';
            container.style.opacity = '0';
            container.offsetHeight;
            const targetHeight = container.scrollHeight;
            container.classList.add('show');
            requestAnimationFrame(() => {
                container.style.maxHeight = targetHeight + 'px';
                container.style.opacity = '1';
            });
            const onExpandEnd = (e) => {
                if (e.propertyName !== 'max-height') return;
                container.removeEventListener('transitionend', onExpandEnd);
                container.style.maxHeight = 'none';
                container.style.overflow = 'visible';
            };
            container.addEventListener('transitionend', onExpandEnd);
            if (chip) chip.classList.add('expanded');
            if (templateBtn) templateBtn.classList.add('is-open');
        }

        function collapseBuilderTasks(container, chip, templateBtn) {
            container.style.overflow = 'hidden';
            const startHeight = container.scrollHeight;
            container.style.maxHeight = startHeight + 'px';
            container.style.opacity = '1';
            container.offsetHeight;
            requestAnimationFrame(() => {
                container.style.maxHeight = '0';
                container.style.opacity = '0';
            });
            const onCollapseEnd = (e) => {
                if (e.propertyName !== 'max-height') return;
                container.removeEventListener('transitionend', onCollapseEnd);
                container.classList.remove('show');
                container.style.display = 'none';
            };
            container.addEventListener('transitionend', onCollapseEnd);
            if (chip) chip.classList.remove('expanded');
            if (templateBtn) templateBtn.classList.remove('is-open');
        }

        function addBuilderTask(phaseId) {
            const ref = findPhaseRef(phaseId);
            if (!ref) return;
            ref.phase.tasks = ref.phase.tasks || [];
            ref.phase.tasks.push('');
            builderFocusTaskKey = `${phaseId}:${ref.phase.tasks.length - 1}`;
            builderExpandedPhaseIds.add(phaseId);
            renderLabelBuilderCanvas();
        }

        function handleBuilderTaskInput(phaseId, index, event) {
            const ref = findPhaseRef(phaseId);
            if (!ref || !ref.phase.tasks) return;
            ref.phase.tasks[index] = event.target.value;
            // If task was confirmed and user is editing, unconfirm it
            const rowKey = `${phaseId}:${index}`;
            if (builderConfirmedTasks.has(rowKey)) {
                builderConfirmedTasks.delete(rowKey);
                renderLabelBuilderCanvas();
            }
        }

        function removeBuilderTask(phaseId, index) {
            const ref = findPhaseRef(phaseId);
            if (!ref || !ref.phase.tasks) return;
            const rowKey = `${phaseId}:${index}`;
            builderConfirmedTasks.delete(rowKey); // Remove from confirmed set
            ref.phase.tasks.splice(index, 1);
            // Update confirmed tasks with higher indices (they shift down)
            // Iterate backwards to avoid index conflicts
            const tasks = ref.phase.tasks;
            const keysToUpdate = [];
            for (let i = index; i < tasks.length; i++) {
                const oldKey = `${phaseId}:${i + 1}`;
                if (builderConfirmedTasks.has(oldKey)) {
                    keysToUpdate.push({ old: oldKey, new: `${phaseId}:${i}` });
                }
            }
            // Apply updates
            keysToUpdate.forEach(({ old, new: newKey }) => {
                builderConfirmedTasks.delete(old);
                builderConfirmedTasks.add(newKey);
            });
            renderLabelBuilderCanvas();
        }

        function confirmBuilderTask(phaseId, index) {
            const ref = findPhaseRef(phaseId);
            if (!ref || !ref.phase.tasks) return;
            const value = (ref.phase.tasks[index] || '').trim();
            if (!value) {
                showNotification('Enter a template task first', 'error');
                const input = document.querySelector(`[data-builder-task-input="${phaseId}:${index}"]`);
                if (input) {
                    input.focus();
                    input.removeAttribute('readonly');
                }
                return;
            }
            ref.phase.tasks[index] = value;
            const rowKey = `${phaseId}:${index}`;
            builderConfirmedTasks.add(rowKey); // Mark as confirmed/saved
            builderExpandedPhaseIds.add(phaseId);
            builderConfirmFlashKey = rowKey;
            if (index === ref.phase.tasks.length - 1) {
                addBuilderTask(phaseId);
            } else {
                renderLabelBuilderCanvas();
            }
        }

        function editBuilderTask(phaseId, index) {
            const rowKey = `${phaseId}:${index}`;
            builderConfirmedTasks.delete(rowKey); // Remove from confirmed set to unlock
            renderLabelBuilderCanvas();
            // Focus the input after a brief delay to ensure it's rendered
            setTimeout(() => {
                const input = document.querySelector(`[data-builder-task-input="${phaseId}:${index}"]`);
                if (input) {
                    input.focus();
                    input.select();
                }
            }, 50);
        }

        function normalizePhaseTree(phases) {
            return (phases || []).map(phase => ({
                id: phase.id || `phase_${Date.now()}_${phaseCounter++}`,
                name: (phase.name || '').trim(),
                tasks: (phase.tasks || []).map(task => task.trim()).filter(Boolean),
                subPhases: normalizePhaseTree(phase.subPhases || [])
            })).filter(phase => phase.name);
        }


        function openPendingFromStats(overdueOnly) {
            switchTab('pending');
            if (overdueOnly) {
                const filtered = getFilteredTasks().filter(t => t.reminderDateTime && new Date(t.reminderDateTime) < new Date() && !t.completed);
                if (filtered.length === 0) {
                    const taskList = document.getElementById('taskList');
                    taskList.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-check-circle"></i>
                        <h3>No overdue tasks</h3>
                        <p>You're all caught up. Nothing is overdue.</p>
                    </div>
                    `;
                    return;
                }
                displayTasks(filtered, true);
            }
        }

        function openCompletedFromStats() {
            switchTab('completed');
        }

        function openClientsFromStats() {
            switchTab('clients');
        }

        function deleteClient(key) {
            const name = key;
            // Remove client meta
            if (clientsMeta[key]) delete clientsMeta[key];
            // Remove client assignment from tasks; keep tasks but clear customer
            tasks.forEach(t => {
                if (t.customer === name) t.customer = '';
            });
            saveTasks();
            updateCustomerList();
            filterTasks();
            if (currentTab === 'clients') renderClients();
            showNotification('Client deleted. Tasks retained without client.', 'success');
        }

        function editTask(taskId) {
            const task = tasks.find(t => t.id === taskId);
            if (!task) return;
            
            currentEditingTaskId = taskId;
            
            // Populate form fields
            document.getElementById('editTaskTitle').value = task.title;
            document.getElementById('editTaskDescription').value = task.description || '';
            
            // Set customer value
            document.getElementById('editCustomerName').value = task.customer || '';
            
            // Set reminder option
            if (!task.reminderDateTime) {
                setEditReminderOption('none');
            } else {
                const reminderDate = new Date(task.reminderDateTime);
                const now = new Date();
                const diffHours = (reminderDate - now) / (1000 * 60 * 60);
                const diffDays = (reminderDate - now) / (1000 * 60 * 60 * 24);
                
                if (Math.abs(diffHours - 3) < 0.5) {
                    setEditReminderOption('3h');
                } else if (Math.abs(diffDays - 1) < 0.1) {
                    setEditReminderOption('1d');
                } else {
                    setEditReminderOption('custom');
                    document.getElementById('editReminderDateTime').value = task.reminderDateTime.slice(0, 16);
                }
            }
            
            // Show modal
            const modal = document.getElementById('editTaskModal');
            modal.classList.add('show');
            
            // Focus on title field
            setTimeout(() => {
                document.getElementById('editTaskTitle').focus();
            }, 300);
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeEditTask();
                }
            };
        }

        function closeEditTask() {
            const modal = document.getElementById('editTaskModal');
            modal.classList.remove('show');
            currentEditingTaskId = null;
        }

        function setEditReminderOption(option) {
            selectedEditReminderOption = option;
            
            const reminderOptions = document.getElementById('editReminderOptions');
            const customDateTime = document.getElementById('editCustomDateTime');
            
            // Update button states
            reminderOptions.querySelectorAll('.reminder-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            
            // Find and activate the clicked button
            const buttons = reminderOptions.querySelectorAll('.reminder-btn');
            const options = ['3h', '1d', 'custom', 'none'];
            const index = options.indexOf(option);
            
            if (index !== -1) {
                buttons[index].classList.add('active');
            }
            
            // Handle animations for custom option
            if (option === 'custom') {
                // Set current date and time as default if not already set
                const currentValue = document.getElementById('editReminderDateTime').value;
                if (!currentValue) {
                    const now = new Date();
                    const currentDateTime = now.toISOString().slice(0, 16);
                    document.getElementById('editReminderDateTime').value = currentDateTime;
                }
                
                customDateTime.classList.add('show');
                setTimeout(() => {
                    document.getElementById('editReminderDateTime').focus();
                }, 200);
            } else {
                customDateTime.classList.remove('show');
            }
        }

        function showEditCustomerSuggestions() {
            const input = document.getElementById('editCustomerName');
            const suggestionsDiv = document.getElementById('editCustomerSuggestions');
            const inputValue = input.value.toLowerCase().trim();
            
            if (inputValue === '') {
                // Show all customers when input is empty
                const suggestions = [...customers].sort();
                displayEditSuggestions(suggestions, suggestionsDiv);
            } else {
                // Filter customers based on input
                const filteredCustomers = [...customers]
                    .filter(customer => customer.toLowerCase().includes(inputValue))
                    .sort();
                displayEditSuggestions(filteredCustomers, suggestionsDiv);
            }
        }

        function displayEditSuggestions(suggestions, suggestionsDiv) {
            if (suggestions.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = suggestions.map((customer, index) => 
                `<div class="customer-suggestion" onclick="selectEditCustomerSuggestion('${escapeHtml(customer)}')" data-index="${index}">
                    ${escapeHtml(customer)}
                </div>`
            ).join('');
            
            suggestionsDiv.style.display = 'block';
        }

        function selectEditCustomerSuggestion(customer) {
            document.getElementById('editCustomerName').value = customer;
            hideEditCustomerSuggestions();
        }

        function hideEditCustomerSuggestions() {
            setTimeout(() => {
                document.getElementById('editCustomerSuggestions').style.display = 'none';
            }, 150);
        }

        function saveTaskEdit() {
            const title = document.getElementById('editTaskTitle').value.trim();
            if (!title) {
                showNotification('Please enter a task title', 'error');
                return;
            }

            const task = tasks.find(t => t.id === currentEditingTaskId);
            if (!task) return;

            const description = document.getElementById('editTaskDescription').value.trim();
            const customer = document.getElementById('editCustomerName').value.trim();
            
            let reminderDateTime = '';
            if (selectedEditReminderOption === 'custom') {
                reminderDateTime = document.getElementById('editReminderDateTime').value;
            } else if (selectedEditReminderOption === '3h') {
                const now = new Date();
                now.setHours(now.getHours() + 3);
                reminderDateTime = now.toISOString().slice(0, 16);
            } else if (selectedEditReminderOption === '1d') {
                const now = new Date();
                now.setDate(now.getDate() + 1);
                reminderDateTime = now.toISOString().slice(0, 16);
            }

            // Update task
            task.title = title;
            task.description = description;
            task.customer = customer;
            task.reminderDateTime = reminderDateTime;
            
            // Parse sub-tasks from updated description
            task.subTasks = parseSubTasks(description);
            
            if (customer) customers.add(customer);
            
            saveTasks();
            updateStats();
            updateCustomerList();
            updateCustomerSuggestions();
            filterTasks();
            
            closeEditTask();
            showNotification('Task updated successfully!', 'success');
        }

        // Filter and display functions
        function getFilteredTasks() {
            const searchTerm = document.getElementById('searchTasks').value.toLowerCase();
            
            return tasks.filter(task => {
                const matchesSearch = task.title.toLowerCase().includes(searchTerm) || 
                                    (task.description && task.description.toLowerCase().includes(searchTerm)) ||
                                    (task.customer && task.customer.toLowerCase().includes(searchTerm));
                const matchesCustomer = !selectedCustomer || task.customer === selectedCustomer;
                const matchesTab = currentTab === 'pending' ? !task.completed : task.completed;
                const matchesCompletedFilter = currentTab === 'pending' || showCompleted || task.completed;
                
                return matchesSearch && matchesCustomer && matchesTab;
            });
        }

        function filterTasksWithoutAnimation() {
            searchTerm = document.getElementById('searchTasks').value.toLowerCase();
            showCompleted = document.getElementById('showCompleted').checked;
            
            const filteredTasks = getFilteredTasks();
            displayTasks(filteredTasks, true); // Skip animations
        }

        function filterTasks() {
            searchTerm = document.getElementById('searchTasks').value.toLowerCase();
            showCompleted = document.getElementById('showCompleted').checked;
            
            const filteredTasks = getFilteredTasks();
            displayTasks(filteredTasks);
        }

        function displayTasks(tasksToShow, skipAnimation = false) {
            const taskList = document.getElementById('taskList');
            
            // Destroy existing sortable instance
            if (sortableInstance) {
                sortableInstance.destroy();
                sortableInstance = null;
            }
            
            if (tasksToShow.length === 0) {
                taskList.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-${currentTab === 'pending' ? 'clipboard-list' : 'check-circle'}"></i>
                        <h3>No ${currentTab} tasks</h3>
                        <p>${currentTab === 'pending' ? 'Add your first task to get started.' : 'Complete some tasks to see them here.'}</p>
                    </div>
                `;
                return;
            }

            // Get existing task IDs to avoid reanimating them
            const existingTaskIds = new Set();
            const existingTasks = taskList.querySelectorAll('[data-task-id]');
            existingTasks.forEach(element => {
                existingTaskIds.add(element.getAttribute('data-task-id'));
            });

            // Sort tasks based on new ordering system
            const sortedTasks = tasksToShow.sort((a, b) => {
                if (currentTab === 'pending') {
                    // Respect manual drag order only when customOrder is a number
                    const aHasOrder = typeof a.customOrder === 'number';
                    const bHasOrder = typeof b.customOrder === 'number';
                    if (aHasOrder && bHasOrder) return a.customOrder - b.customOrder;
                    if (aHasOrder && !bHasOrder) return -1;
                    if (bHasOrder && !aHasOrder) return 1;

                    // Default: reminders first (closest first), otherwise newest created first
                    const aHasReminder = a.reminderDateTime && !a.completed;
                    const bHasReminder = b.reminderDateTime && !b.completed;
                    if (aHasReminder && bHasReminder) return new Date(a.reminderDateTime) - new Date(b.reminderDateTime);
                    if (aHasReminder && !bHasReminder) return -1;
                    if (!aHasReminder && bHasReminder) return 1;
                    return new Date(b.createdAt) - new Date(a.createdAt);
                } else {
                    // Completed: newest completion first
                    return new Date(b.completedAt) - new Date(a.completedAt);
                }
            });

            taskList.innerHTML = sortedTasks
                .map(task => createTaskHTML(task, skipAnimation || existingTaskIds.has(task.id)))
                .join('');

            // Initialize drag and drop only for pending tasks
            if (currentTab === 'pending' && tasksToShow.length > 1) {
                initializeSortable();
            }
        }

        function createTaskHTML(task, skipAnimation = false) {
            const isOverdue = task.reminderDateTime && new Date(task.reminderDateTime) < new Date() && !task.completed;

            // Create sub-tasks HTML
            let subTasksHTML = '';
            let progressHTML = '';
            
            if (task.subTasks && task.subTasks.length > 0) {
                const progress = getSubTaskProgress(task);
                progressHTML = `<div class="sub-task-progress">
                    <i class="fas fa-tasks"></i> ${progress.completed}/${progress.total} completed (${progress.percentage}%)
                </div>`;
                
                subTasksHTML = `<div class="sub-tasks">
                    ${task.subTasks.map(subTask => `
                        <div class="sub-task">
                            <input type="checkbox" 
                                   class="sub-task-checkbox" 
                                   ${subTask.completed ? 'checked' : ''} 
                                   onchange="toggleSubTask('${task.id}', '${subTask.id}')"
                                   ${task.completed ? 'disabled' : ''}>
                            <span class="sub-task-text ${subTask.completed ? 'completed' : ''}">${escapeHtml(subTask.text)}</span>
                        </div>
                    `).join('')}
                </div>`;
            }

            // Filter out bullet points from description display
            let displayDescription = '';
            if (task.description) {
                const lines = task.description.split('\n');
                const nonBulletLines = lines.filter(line => !line.trim().startsWith('- '));
                if (nonBulletLines.some(line => line.trim())) {
                    displayDescription = `<div style="color: var(--light-text); font-size: 0.9rem; margin-top: 5px; line-height: 1.4; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;">${escapeHtml(nonBulletLines.join('\n').trim())}</div>`;
                }
            }

            return `
                <div class="task-item ${task.completed ? 'completed' : ''} ${skipAnimation ? '' : 'fade-in'}" data-task-id="${task.id}">
                    <div class="task-controls">
                        <button class="task-control-btn" onclick="moveTaskToTop('${task.id}')" title="Move to Top">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="task-control-btn" onclick="showTaskInfo('${task.id}')" title="Task Information">
                            <i class="fas fa-info-circle"></i>
                        </button>
                        <button class="task-control-btn" onclick="editTask('${task.id}')" title="Edit Task">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="task-control-btn delete" onclick="deleteTask('${task.id}')" title="Delete Task">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    
                    <div class="task-header">
                        <div>
                            <div class="task-title">${escapeHtml(task.title)}</div>
                            ${displayDescription}
                            ${progressHTML}
                            ${subTasksHTML}
                            ${task.customer ? `<span class="task-customer" style="margin-top: 8px; display: inline-block;">${escapeHtml(task.customer)}</span>` : ''}
                        </div>
                    </div>
                    
                    <div class="task-meta">
                        ${task.completedAt ? `<div><i class="fas fa-check"></i> Completed: ${formatDateTime(task.completedAt)}</div>` : ''}
                    </div>
                    
                    <div class="task-actions">
                        <div class="task-action-buttons">
                            ${!task.completed ? 
                                `<button class="btn btn-success btn-sm" onclick="completeTask('${task.id}')">
                                    <i class="fas fa-check"></i> Complete
                                </button>` :
                                `<button class="btn btn-primary btn-sm" onclick="uncompleteTask('${task.id}')">
                                    <i class="fas fa-undo"></i> Undo
                                </button>`
                            }
                        </div>
                        ${task.reminderDateTime ? `
                            <div class="task-deadline ${new Date(task.reminderDateTime) < new Date() && !task.completed ? 'overdue' : ''}">
                                <i class="fas fa-${new Date(task.reminderDateTime) < new Date() && !task.completed ? 'exclamation-triangle' : 'clock'}"></i>
                                ${formatDateTime(task.reminderDateTime)}
                            </div>
                        ` : ''}
                    </div>
                </div>
            `;
        }

        // Drag and Drop functionality
        function initializeSortable() {
            const taskList = document.getElementById('taskList');
            
            sortableInstance = new Sortable(taskList, {
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                dragClass: 'sortable-drag',
                animation: 150,
                easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
                filter: '.task-controls, .task-controls *, .sub-task-checkbox, .btn, .btn *, .task-title, .task-description, .task-customer, .sub-task-text, .task-deadline',
                preventOnFilter: false,
                onEnd: function(evt) {
                    // Update task custom order based on new positions
                    const taskElements = taskList.querySelectorAll('[data-task-id]');
                    const reorderedIds = Array.from(taskElements).map(el => el.getAttribute('data-task-id'));
                    
                    // Update customOrder property for all visible tasks
                    reorderedIds.forEach((taskId, index) => {
                        const task = tasks.find(t => t.id === taskId);
                        if (task) {
                            task.customOrder = index;
                        }
                    });
                    
                    saveTasks();
                    showNotification('Task order updated', 'success');
                },
                onStart: function(evt) {
                    // Add visual feedback when dragging starts
                    evt.item.style.zIndex = '1000';
                },
                onMove: function(evt) {
                    // Prevent dropping on completed tasks or other elements
                    return evt.related.classList.contains('task-item');
                }
            });
        }

        // Tab management
        function switchTab(tab) {
            currentTab = tab;
            // Persist tab selection with settings
            saveSettingsToStorage();
            persistLog('tab.switch', { currentTab });
            
            // Update tab appearance (do not rely on event)
            document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
            const targetTab = document.querySelector(`.tabs-container .tab[onclick="switchTab('${tab}')"]`);
            if (targetTab) targetTab.classList.add('active');
            
            const myToggle = document.getElementById('myClientsToggle');
            if (currentTab === 'clients') {
                if (myToggle) myToggle.style.display = 'inline-flex';
                renderClients(); // rendering clients has no per-item fade-in
            } else {
                if (myToggle) myToggle.style.display = 'none';
                filterTasksWithoutAnimation(); // avoid fade-in each time tab opens
            }
        }

        // Customer management
        function selectCustomer(customer) {
            selectedCustomer = customer;
            
            // Update customer list appearance
            document.querySelectorAll('.customer-item').forEach(item => {
                item.classList.remove('active');
            });
            event.target.closest('.customer-item').classList.add('active');
            
            filterTasks();
        }

        function updateCustomerList() {
            const customerList = document.getElementById('customerList');
            const allCustomerItem = customerList.querySelector('.customer-item');
            
            // Update all customers count
            document.getElementById('allCustomerCount').textContent = tasks.length;
            
            // Remove existing customer items (except "All Customers")
            const existingItems = customerList.querySelectorAll('.customer-item:not(:first-child)');
            existingItems.forEach(item => item.remove());
            
            // Add customer items
            const customerCounts = {};
            tasks.forEach(task => {
                if (task.customer) {
                    customerCounts[task.customer] = (customerCounts[task.customer] || 0) + 1;
                }
            });
            
            // Sync the customers Set used by Clients tab
            customers = new Set(Object.keys(customerCounts));
            // Update Clients tab badge count
            const clientsBadge = document.getElementById('clientsBadge');
            if (clientsBadge) clientsBadge.textContent = Object.keys(customerCounts).length;

            Object.entries(customerCounts)
                .sort(([a], [b]) => a.localeCompare(b))
                .forEach(([customer, count]) => {
                    const customerItem = document.createElement('div');
                    customerItem.className = 'customer-item';
                    customerItem.onclick = () => selectCustomer(customer);
                    customerItem.innerHTML = `
                        <span><i class="fas fa-user"></i> ${escapeHtml(customer)}</span>
                        <span class="customer-count">${count}</span>
                    `;
                    customerList.appendChild(customerItem);
                });

            // If the Clients tab is active, re-render to reflect changes immediately
            if (currentTab === 'clients') {
                renderClients();
            }
        }

        let selectedSuggestionIndex = -1;

        function updateCustomerSuggestions() {
            // This function is kept for compatibility but now does nothing
            // as we use the new autocomplete approach
        }

        function showCustomerSuggestions() {
            const input = document.getElementById('customerName');
            const suggestionsDiv = document.getElementById('customerSuggestions');
            const inputValue = input.value.toLowerCase().trim();
            
            if (inputValue === '') {
                // Show all customers when input is empty
                const suggestions = [...customers].sort();
                displaySuggestions(suggestions, suggestionsDiv);
            } else {
                // Filter customers based on input
                const filteredCustomers = [...customers]
                    .filter(customer => customer.toLowerCase().includes(inputValue))
                    .sort();
                displaySuggestions(filteredCustomers, suggestionsDiv);
            }
        }

        function displaySuggestions(suggestions, suggestionsDiv) {
            selectedSuggestionIndex = -1;
            
            if (suggestions.length === 0) {
                suggestionsDiv.style.display = 'none';
                return;
            }

            suggestionsDiv.innerHTML = suggestions.map((customer, index) => 
                `<div class="customer-suggestion" onclick="selectCustomerSuggestion('${escapeHtml(customer)}')" data-index="${index}">
                    ${escapeHtml(customer)}
                </div>`
            ).join('');
            
            suggestionsDiv.style.display = 'block';
        }

        function selectCustomerSuggestion(customer) {
            document.getElementById('customerName').value = customer;
            hideCustomerSuggestions();
        }

        function hideCustomerSuggestions() {
            setTimeout(() => {
                document.getElementById('customerSuggestions').style.display = 'none';
            }, 150); // Small delay to allow click events to register
        }

        // Enhanced enter key handling for customer autocomplete
        function handleEnterKey(event) {
            if (event.target.id === 'customerName') {
                const suggestionsDiv = document.getElementById('customerSuggestions');
                const suggestions = suggestionsDiv.querySelectorAll('.customer-suggestion');
                
                if (event.key === 'ArrowDown') {
                    event.preventDefault();
                    selectedSuggestionIndex = Math.min(selectedSuggestionIndex + 1, suggestions.length - 1);
                    updateSuggestionHighlight(suggestions);
                    return;
                } else if (event.key === 'ArrowUp') {
                    event.preventDefault();
                    selectedSuggestionIndex = Math.max(selectedSuggestionIndex - 1, -1);
                    updateSuggestionHighlight(suggestions);
                    return;
                } else if (event.key === 'Enter') {
                    event.preventDefault();
                    if (selectedSuggestionIndex >= 0 && suggestions[selectedSuggestionIndex]) {
                        const selectedCustomer = suggestions[selectedSuggestionIndex].textContent.trim();
                        selectCustomerSuggestion(selectedCustomer);
                    } else {
                        // Just hide suggestions and proceed with current value
                        hideCustomerSuggestions();
                        addTask();
                    }
                    return;
                } else if (event.key === 'Escape') {
                    hideCustomerSuggestions();
                    return;
                }
            }
            
            if (event.key === 'Enter' && !event.shiftKey) {
                event.preventDefault();
                addTask();
            }
        }

        function updateSuggestionHighlight(suggestions) {
            suggestions.forEach((suggestion, index) => {
                if (index === selectedSuggestionIndex) {
                    suggestion.classList.add('highlighted');
                } else {
                    suggestion.classList.remove('highlighted');
                }
            });
        }

        // Statistics
        function updateStats() {
            // Total Clients = number of unique clients derived from tasks
            const uniqueClients = Array.from(new Set(tasks.map(t => t.customer).filter(Boolean)));
            const total = uniqueClients.length;
            const pending = tasks.filter(t => !t.completed).length;
            const completed = tasks.filter(t => t.completed).length;
            const overdue = tasks.filter(t => 
                t.reminderDateTime && 
                new Date(t.reminderDateTime) < new Date() && 
                !t.completed
            ).length;
            
            const totalEl = document.getElementById('totalTasks');
            if (totalEl) totalEl.textContent = total;
            document.getElementById('pendingTasks').textContent = pending;
            document.getElementById('completedTasks').textContent = completed;
            document.getElementById('overdueReminders').textContent = overdue;
            
            document.getElementById('pendingBadge').textContent = pending;
            document.getElementById('completedBadge').textContent = completed;
        }

        // Notifications and reminders
        function setupNotifications() {
            if (!('Notification' in window)) return;
            try {
                if (Notification.permission === 'default') {
                    const requestOnce = () => {
                        try { Notification.requestPermission().catch(() => {}); } catch (e) {}
                        document.removeEventListener('click', requestOnce);
                    };
                    document.addEventListener('click', requestOnce, { once: true });
                }
            } catch (e) {
                // Ignore
            }
        }

        function checkReminders() {
            const now = new Date();
            const upcomingTasks = tasks.filter(task => {
                if (!task.reminderDateTime || task.completed) return false;
                const reminderTime = new Date(task.reminderDateTime);
                return reminderTime <= now && reminderTime > new Date(now.getTime() - 60000);
            });

            upcomingTasks.forEach(task => {
                showNotification(`Reminder: ${task.title}`, 'warning');
                
                if ('Notification' in window && Notification.permission === 'granted') {
                    new Notification('Task Reminder', {
                        body: task.title,
                        icon: '/favicon.ico'
                    });
                }
            });
            
            updateStats(); // Update overdue count
        }

        function showNotification(message, type = 'success') {
            const notification = document.createElement('div');
            notification.className = `notification ${type}`;
            notification.innerHTML = `
                <i class="fas fa-${type === 'success' ? 'check' : type === 'error' ? 'times' : 'exclamation-triangle'}"></i>
                ${message}
            `;
            
            document.body.appendChild(notification);
            
            setTimeout(() => notification.classList.add('show'), 100);
            setTimeout(() => {
                notification.classList.remove('show');
                setTimeout(() => document.body.removeChild(notification), 300);
            }, 3000);
        }

        function showExportNotification() {
            // Check if notification already exists
            const existingNotification = document.querySelector('.export-prompt');
            if (existingNotification) {
                console.log('Export notification already visible, skipping');
                return;
            }
            
            const notification = document.createElement('div');
            notification.className = 'notification export-prompt';
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                padding: 20px;
                background: var(--secondary-color);
                color: var(--white);
                border-radius: 8px;
                font-weight: 600;
                z-index: 1000;
                box-shadow: var(--shadow-hover);
                max-width: 350px;
                transform: translateX(400px);
                transition: var(--transition);
                animation: pulse 2s ease-in-out infinite;
            `;
            
            notification.innerHTML = `
                <div style="margin-bottom: 15px;">
                    <i class="fas fa-upload" style="margin-right: 8px;"></i>
                    <strong>Scheduled Export Ready</strong>
                </div>
                <div style="margin-bottom: 15px; font-weight: normal; opacity: 0.9;">
                    It's time for your automatic task export. This reminder will persist until you take action.
                </div>
                <div style="display: flex; gap: 10px;">
                    <button onclick="confirmExport(this)" style="
                        background: var(--white);
                        color: var(--secondary-color);
                        border: none;
                        padding: 8px 16px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                        flex: 1;
                    ">
                        <i class="fas fa-download"></i> Export Now
                    </button>
                    <button onclick="skipExport(this)" style="
                        background: rgba(255,255,255,0.2);
                        color: var(--white);
                        border: 1px solid rgba(255,255,255,0.3);
                        padding: 8px 16px;
                        border-radius: 6px;
                        cursor: pointer;
                        font-weight: 600;
                        flex: 1;
                    ">
                        <i class="fas fa-times"></i> Skip
                    </button>
                </div>
            `;
            
            document.body.appendChild(notification);
            
            // Show notification
            setTimeout(() => {
                notification.style.transform = 'translateX(0)';
            }, 100);
            
            // NO auto-dismiss - user must take action
        }

        function confirmExport(button) {
            const notification = button.closest('.export-prompt');
            
            // Trigger export
            exportTasksAsJSON(true);
            
            // Mark as exported today
            const now = new Date();
            localStorage.setItem('lastAutoExport', now.toISOString());
            
            // Clear pending export flag
            localStorage.removeItem('pendingExport');
            
            // Remove notification
            notification.style.transform = 'translateX(400px)';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 300);
        }

        function skipExport(button) {
            const notification = button.closest('.export-prompt');
            
            // Remove notification
            notification.style.transform = 'translateX(400px)';
            setTimeout(() => {
                if (document.body.contains(notification)) {
                    document.body.removeChild(notification);
                }
            }, 300);
            
            // Clear pending export flag - user explicitly skipped
            localStorage.removeItem('pendingExport');
            
            // Mark as skipped for this scheduled export
            const now = new Date();
            localStorage.setItem('lastAutoExport', now.toISOString());
            
            // Show brief message
            showNotification('Export skipped. You can manually export anytime from settings.', 'warning');
        }

        // For backwards compatibility - redirect old dismissExport calls to skipExport
        function dismissExport(button) {
            skipExport(button);
        }

        // Check for pending exports on page load
        function checkPendingExport() {
            // Clean up old dismissal system (backwards compatibility)
            localStorage.removeItem('lastExportDismissal');
            
            const pendingExportData = localStorage.getItem('pendingExport');
            
            if (pendingExportData) {
                try {
                    const pendingExport = JSON.parse(pendingExportData);
                    console.log('Found pending export from:', pendingExport);
                    
                    // Show the notification
                    setTimeout(() => {
                        showExportNotification();
                    }, 1000); // Wait 1 second after page load to show notification
                } catch (error) {
                    console.error('Error parsing pending export data:', error);
                    // Clean up corrupted data
                    localStorage.removeItem('pendingExport');
                }
            }
        }

        // Offline functionality
        function setupOfflineDetection() {
            const offlineIndicator = document.getElementById('offlineIndicator');
            
            function updateOnlineStatus() {
                if (navigator.onLine) {
                    offlineIndicator.classList.remove('show');
                } else {
                    offlineIndicator.classList.add('show');
                }
            }
            
            window.addEventListener('online', updateOnlineStatus);
            window.addEventListener('offline', updateOnlineStatus);
            updateOnlineStatus();
        }

        // Smart Export Scheduling
        function setupSmartExportScheduling() {
            console.log('Setting up smart export scheduling...');
            
            // Clear existing timers
            clearSmartExportScheduling();
            
            if (!autoExportEnabled || autoExportDays.length === 0) {
                console.log('Auto export disabled or no days configured');
                return;
            }
            
            // Schedule checks for each configured export time
            scheduleNextExportCheck();
            
            // Also set up a backup check every 30 minutes to catch any missed schedules
            autoExportInterval = setInterval(() => {
                console.log('Backup export check...');
                checkFridayExport();
            }, 30 * 60 * 1000); // Every 30 minutes
            
            console.log('Smart scheduling setup complete');
        }
        
        function clearSmartExportScheduling() {
            if (autoExportTimeout) {
                clearTimeout(autoExportTimeout);
                autoExportTimeout = null;
                console.log('Cleared export timeout');
            }
            
            if (autoExportInterval) {
                clearInterval(autoExportInterval);
                autoExportInterval = null;
                console.log('Cleared export interval');
            }
        }
        
        function scheduleNextExportCheck() {
            const nextExport = getNextExportDate();
            
            if (!nextExport) {
                console.log('No next export date found');
                return;
            }
            
            const now = new Date();
            const msUntilExport = nextExport.getTime() - now.getTime();
            
            console.log('Next export scheduled for:', nextExport.toISOString());
            console.log('Time until next export:', Math.round(msUntilExport / 1000 / 60), 'minutes');
            
            if (msUntilExport > 0) {
                // Schedule the export check
                autoExportTimeout = setTimeout(() => {
                    console.log('Scheduled export check triggered!');
                    checkFridayExport();
                    
                    // Schedule the next one after a delay
                    setTimeout(() => {
                        scheduleNextExportCheck();
                    }, 5000); // Wait 5 seconds then schedule next
                }, msUntilExport);
                
                console.log('Export timeout scheduled, ID:', autoExportTimeout);
            } else if (msUntilExport > -60000) { // Only if less than 1 minute in the past
                console.log('Next export time is in the past (but recent), checking now...');
                checkFridayExport();
                
                // Schedule the next one after a longer delay to avoid loops
                setTimeout(() => {
                    scheduleNextExportCheck();
                }, 10000); // Wait 10 seconds then schedule next
            } else {
                console.log('Next export time is too far in the past, skipping to next occurrence...');
                // Skip this occurrence and find the next one
                setTimeout(() => {
                    scheduleNextExportCheck();
                }, 1000);
            }
        }

        // Export functionality
        function checkFridayExport() {
            if (!autoExportEnabled || autoExportDays.length === 0) {
                return;
            }
            
            const now = new Date();
            const today = now.getDay();
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const [exportHours, exportMinutes] = autoExportTime.split(':').map(Number);
            const exportTimeMinutes = exportHours * 60 + exportMinutes;
            const today_string = now.toISOString().split('T')[0]; // YYYY-MM-DD format
            
            console.log('Auto export check:', {
                today: today,
                currentTime: Math.floor(currentTime/60) + ':' + String(currentTime%60).padStart(2,'0'),
                exportTime: exportHours + ':' + String(exportMinutes).padStart(2,'0'),
                isExportDay: autoExportDays.includes(today),
                isTimeReached: currentTime >= exportTimeMinutes
            });
            
            const lastExportKey = 'lastAutoExport';
            const lastExport = localStorage.getItem(lastExportKey);
            const lastExportDate = lastExport ? new Date(lastExport) : null;
            
            // Check if we've missed any export days
            let missedExport = false;
            let missedExportDay = null;
            
            if (lastExportDate) {
                // Check each day since last export
                const daysSinceExport = Math.floor((now - lastExportDate) / (1000 * 60 * 60 * 24));
                
                for (let i = 1; i <= daysSinceExport; i++) {
                    const checkDate = new Date(lastExportDate);
                    checkDate.setDate(checkDate.getDate() + i);
                    const dayOfWeek = checkDate.getDay();
                    
                    // If this was an export day and we're past the time (or it's a past day)
                    if (autoExportDays.includes(dayOfWeek)) {
                        const isToday = checkDate.toISOString().split('T')[0] === today_string;
                        const isPastTime = currentTime >= exportTimeMinutes;
                        
                        if (!isToday || isPastTime) {
                            missedExport = true;
                            missedExportDay = checkDate.toISOString().split('T')[0];
                            console.log('AUTO EXPORT: Missed export on', missedExportDay);
                            break;
                        }
                    }
                }
            } else {
                // No last export - check if today is export day and time has passed
                if (autoExportDays.includes(today) && currentTime >= exportTimeMinutes) {
                    missedExport = true;
                    missedExportDay = today_string;
                }
            }
            
            if (missedExport) {
                console.log('AUTO EXPORT: Setting pending export flag for', missedExportDay);
                // Set pending export flag with timestamp
                localStorage.setItem('pendingExport', JSON.stringify({
                    scheduledDate: missedExportDay,
                    scheduledTime: autoExportTime,
                    timestamp: now.toISOString()
                }));
                
                // Show notification
                console.log('AUTO EXPORT: Triggering export notification');
                try {
                    showExportNotification();
                } catch (error) {
                    console.error('AUTO EXPORT: Error showing notification:', error);
                }
            } else {
                console.log('AUTO EXPORT: No missed exports');
            }
        }
        
        function getWeekNumber(date) {
            const firstDayOfYear = new Date(date.getFullYear(), 0, 1);
            const pastDaysOfYear = (date - firstDayOfYear) / 86400000;
            return Math.ceil((pastDaysOfYear + firstDayOfYear.getDay() + 1) / 7);
        }
        
        function exportTasksAsJSON(isAutomatic = false) {
            try {
                const exportData = {
                    exportDate: new Date().toISOString(),
                    exportType: isAutomatic ? 'automatic' : 'manual',
                    tasks: tasks,
                    customers: [...customers],
                    clientsMeta: clientsMeta, // Include client notes, assigned status, order, and labels
                    clientLabels: clientLabels, // Include global workflows
                    simpleLabels: simpleLabels, // Include simple labels (independent of workflows)
                    stats: {
                        total: tasks.length,
                        pending: tasks.filter(t => !t.completed).length,
                        completed: tasks.filter(t => t.completed).length,
                        overdue: tasks.filter(t => 
                            t.reminderDateTime && 
                            new Date(t.reminderDateTime) < new Date() && 
                            !t.completed
                        ).length
                    }
                };
                
                const dataStr = JSON.stringify(exportData, null, 2);
                const dataUri = 'data:application/json;charset=utf-8,'+ encodeURIComponent(dataStr);
                const exportFileDefaultName = `legal-tasks-${new Date().toISOString().split('T')[0]}.json`;
                
                const linkElement = document.createElement('a');
                linkElement.setAttribute('href', dataUri);
                linkElement.setAttribute('download', exportFileDefaultName);
                linkElement.click();
                
                // Track export for statistics
                const now = new Date();
                localStorage.setItem('lastExport', now.toISOString());
                localStorage.setItem('lastExportType', isAutomatic ? 'automatic' : 'manual');
                
                console.log('Export download triggered:', exportFileDefaultName, `(${exportData.stats.total} tasks)`);
            } catch (error) {
                console.error('Export error:', error);
                showNotification('Error during export', 'error');
                throw error;
            }
        }

        // Import functionality
        function importTasks() {
            document.getElementById('importFileInput').click();
        }

        function handleFileImport(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (file.type !== 'application/json') {
                showNotification('Please select a valid JSON file', 'error');
                return;
            }

            const reader = new FileReader();
            reader.onload = function(e) {
                try {
                    const importData = JSON.parse(e.target.result);
                    
                    // Debug logging
                    console.log('Parsed import data:', importData);
                    
                    // Validate the import data structure
                    if (!validateImportData(importData)) {
                        console.error('Validation failed for import data:', importData);
                        showNotification('Invalid file format. Please select a valid task export file.', 'error');
                        return;
                    }

                    // Show confirmation dialog with import details
                    showImportConfirmation(importData);
                    
                } catch (error) {
                    console.error('Import parsing error:', error);
                    showNotification('Error reading file. Please ensure it\'s a valid JSON file.', 'error');
                }
            };
            
            reader.readAsText(file);
            // Clear the input so the same file can be selected again
            event.target.value = '';
        }

        /**
         * IMPORTANT: BACKWARDS COMPATIBILITY NOTE
         * 
         * When modifying the task data structure or import/export functionality,
         * ALWAYS ensure backwards compatibility with older export files.
         * 
         * Key principles:
         * 1. New properties should be optional and have sensible defaults
         * 2. Validation should only check for essential properties (id, title, completed)
         * 3. Import functions should gracefully handle missing properties
         * 4. When adding new properties, update the performImport() function to set defaults
         * 5. Test imports with old export files before releasing changes
         * 
         * Current essential properties: id, title, completed
         * Optional properties: createdAt, completedAt, description, customer, reminderDateTime, 
         *                      subTasks, order, customOrder, stats, exportDate, exportType
         */
        function validateImportData(data) {
            // Check if it has the expected structure
            if (!data || typeof data !== 'object') return false;
            if (!Array.isArray(data.tasks)) return false;
            if (!Array.isArray(data.customers)) return false;
            
            // Validate task structure - be more flexible for backwards compatibility
            return data.tasks.every(task => 
                task.id && 
                task.title && 
                typeof task.completed === 'boolean'
                // All other properties are optional for backwards compatibility:
                // - createdAt, completedAt, description, customer, reminderDateTime, subTasks, order, customOrder
            );
        }

        // Global variable to store import data for the modal
        let pendingImportData = null;

        function showImportConfirmation(importData) {
            const stats = importData.stats || {
                total: importData.tasks.length,
                pending: importData.tasks.filter(t => !t.completed).length,
                completed: importData.tasks.filter(t => t.completed).length
            };
            
            const exportDate = importData.exportDate ? new Date(importData.exportDate).toLocaleDateString() : 'Unknown';
            
            // Check for duplicate task IDs
            const existingIds = new Set(tasks.map(t => t.id));
            const duplicates = importData.tasks.filter(t => existingIds.has(t.id));
            const newTasks = importData.tasks.filter(t => !existingIds.has(t.id));
            
            // Store import data for when user confirms
            pendingImportData = importData;
            
            // Build the summary HTML
            let summaryHTML = `
                <div style="margin-bottom: 12px;">
                    <strong>📅 Export Date:</strong> ${exportDate}
                </div>
                <div style="display: grid; grid-template-columns: repeat(2, 1fr); gap: 12px; margin-bottom: 15px;">
                    <div style="text-align: center; padding: 10px; background: rgba(52, 152, 219, 0.1); border-radius: 6px;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #3498db;">${stats.pending}</div>
                        <div style="font-size: 0.9em; color: var(--light-text);">Pending Tasks</div>
                    </div>
                    <div style="text-align: center; padding: 10px; background: rgba(39, 174, 96, 0.1); border-radius: 6px;">
                        <div style="font-size: 1.2em; font-weight: 600; color: #27ae60;">${stats.completed}</div>
                        <div style="font-size: 0.9em; color: var(--light-text);">Completed Tasks</div>
                    </div>
                </div>
                <div style="text-align: center; padding: 8px; background: rgba(155, 89, 182, 0.1); border-radius: 6px;">
                    <span style="font-weight: 600; color: #9b59b6;">${importData.customers.length}</span> customers
                </div>
            `;
            
            // Build safety message
            let safetyMessage = '';
            if (duplicates.length > 0) {
                safetyMessage = `${duplicates.length} existing tasks will be updated with new data, and ${newTasks.length} completely new tasks will be added to your collection.`;
            } else {
                safetyMessage = `All ${stats.total} tasks are new and will be added to your existing collection. None of your current tasks will be modified.`;
            }
            
            // Update modal content
            document.getElementById('importSummary').innerHTML = summaryHTML;
            document.getElementById('importSafetyMessage').textContent = safetyMessage;
            
            // Show the modal
            const modal = document.getElementById('importConfirmModal');
            modal.classList.add('show');
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeImportConfirm();
                }
            };
        }

        function closeImportConfirm() {
            const modal = document.getElementById('importConfirmModal');
            modal.classList.remove('show');
            pendingImportData = null;
        }

        function confirmImport() {
            if (pendingImportData) {
                // Store the data before closing the modal to avoid race condition
                const importData = pendingImportData;
                closeImportConfirm();
                performImport(importData);
            } else {
                console.error('No pending import data available');
                showNotification('Import data is missing. Please try importing again.', 'error');
            }
        }

        function performImport(importData) {
            try {
                // Validate importData is not null
                if (!importData || !importData.tasks) {
                    throw new Error('Invalid import data: missing tasks array');
                }
                
                // See validateImportData() function above for backwards compatibility guidelines
                
                // Merge tasks instead of replacing
                const existingIds = new Set(tasks.map(t => t.id));
                let updatedCount = 0;
                let addedCount = 0;
                
                importData.tasks.forEach(importTask => {
                    // Ensure backward compatibility for any missing properties
                    if (!importTask.subTasks) {
                        importTask.subTasks = parseSubTasks(importTask.description || '');
                    }
                    
                    // Ensure createdAt exists for backwards compatibility
                    if (!importTask.createdAt) {
                        importTask.createdAt = new Date().toISOString();
                    }
                    
                    // Ensure completedAt exists if task is completed
                    if (importTask.completed && !importTask.completedAt) {
                        importTask.completedAt = new Date().toISOString();
                    }
                    
                    // Ensure order exists
                    if (importTask.order === undefined) {
                        importTask.order = tasks.length + 1;
                    }
                    
                    // Ensure customer exists (can be empty string)
                    if (importTask.customer === undefined) {
                        importTask.customer = '';
                    }
                    
                    // Ensure reminderDateTime exists (can be empty string)
                    if (importTask.reminderDateTime === undefined) {
                        importTask.reminderDateTime = '';
                    }
                    
                    // Ensure description exists (can be empty string)
                    if (importTask.description === undefined) {
                        importTask.description = '';
                    }
                    
                    // Ensure customOrder exists if not present
                    if (importTask.customOrder === undefined) {
                        importTask.customOrder = null;
                    }
                    
                    if (existingIds.has(importTask.id)) {
                        // Update existing task
                        const index = tasks.findIndex(t => t.id === importTask.id);
                        if (index !== -1) {
                            tasks[index] = importTask;
                            updatedCount++;
                        }
                    } else {
                        // Add new task
                        tasks.push(importTask);
                        addedCount++;
                    }
                });
                
                // Merge customers (add new ones, keep existing) with backward compatibility
                const importedCustomers = Array.isArray(importData.customers) && importData.customers.length > 0
                    ? importData.customers
                    : Array.from(new Set((importData.tasks || [])
                        .map(t => t.customer)
                        .filter(Boolean)));
                importedCustomers.forEach(customer => {
                    customers.add(customer);
                });
                
                // Merge clientsMeta (notes, assigned status, order, labels) with backwards compatibility
                // Only import if it exists in the export file (for backwards compatibility)
                if (importData.clientsMeta && typeof importData.clientsMeta === 'object') {
                    // Merge with existing clientsMeta - don't replace, only add/update
                    Object.keys(importData.clientsMeta).forEach(key => {
                        if (!clientsMeta[key]) {
                            // New client metadata - add it
                            clientsMeta[key] = importData.clientsMeta[key];
                        } else {
                            // Existing client - merge properties, preferring imported data
                            clientsMeta[key] = {
                                ...clientsMeta[key],
                                ...importData.clientsMeta[key]
                            };
                        }
                    });
                    saveClientsMeta();
                }
                
                // Merge clientLabels (workflows) with backwards compatibility
                if (importData.clientLabels && Array.isArray(importData.clientLabels)) {
                    // Merge labels - add new ones that don't exist
                    importData.clientLabels.forEach(label => {
                        if (!clientLabels.includes(label)) {
                            clientLabels.push(label);
                        }
                    });
                    saveClientLabels();
                }
                
                // Merge simpleLabels with backwards compatibility
                if (importData.simpleLabels && Array.isArray(importData.simpleLabels)) {
                    // Merge simple labels - add new ones that don't exist
                    importData.simpleLabels.forEach(label => {
                        if (!simpleLabels.some(l => l.id === label.id || l.name === label.name)) {
                            simpleLabels.push(label);
                        }
                    });
                    saveSimpleLabels();
                }
                
                // Save merged data
                saveTasks();
                
                // Update UI
                updateStats();
                updateCustomerList();
                updateCustomerSuggestions();
                filterTasks();
                
                // Close settings modal
                closeSettings();
                
                const totalImported = updatedCount + addedCount;
                let message = `Successfully imported ${totalImported} tasks!`;
                if (updatedCount > 0 && addedCount > 0) {
                    message += ` (${addedCount} new, ${updatedCount} updated)`;
                } else if (updatedCount > 0) {
                    message += ` (${updatedCount} updated)`;
                } else {
                    message += ` (${addedCount} new)`;
                }
                
                showNotification(message, 'success');
                
            } catch (error) {
                console.error('Import error:', error);
                showNotification('Error importing tasks. Please try again.', 'error');
            }
        }

        // Settings functionality
        function openSettings() {
            loadSettings();
            updateSettingsDisplay();
            
            const modal = document.getElementById('settingsModal');
            modal.classList.add('show');
            
            // Close modal when clicking outside
            modal.onclick = function(e) {
                if (e.target === modal) {
                    closeSettings();
                }
            };
        }

        function closeSettings() {
            const modal = document.getElementById('settingsModal');
            modal.classList.remove('show');
        }

        function loadSettings() {
            try {
                const savedSettings = localStorage.getItem('legalTasksSettings');
                
                if (savedSettings) {
                    const settings = JSON.parse(savedSettings);
                    persistLog('settings.load', settings);
                    autoExportEnabled = settings.autoExportEnabled !== undefined ? settings.autoExportEnabled : true;
                    autoExportDays = settings.autoExportDays !== undefined ? settings.autoExportDays : [5];
                    autoExportTime = settings.autoExportTime !== undefined ? settings.autoExportTime : '16:00';
                    clientsTabEnabled = settings.clientsTabEnabled !== undefined ? settings.clientsTabEnabled : true;
                    // Persisted Clients filter
                    myClientsOnly = settings.myClientsOnly !== undefined ? settings.myClientsOnly : false;
                    // Persisted selected tab
                    if (settings.currentTab) {
                        // If saved tab is clients but clients tab is disabled, fallback to pending
                        if (settings.currentTab === 'clients' && !clientsTabEnabled) {
                            currentTab = 'pending';
                        } else {
                            currentTab = settings.currentTab;
                        }
                    }
                    
                    // Handle legacy single day setting
                    if (settings.autoExportDay !== undefined && !settings.autoExportDays) {
                        autoExportDays = [settings.autoExportDay];
                    }
                    
                    console.log('Settings loaded:', {
                        autoExportEnabled,
                        autoExportDays,
                        autoExportTime
                    });
                    persistLog('settings.apply', { clientsTabEnabled, myClientsOnly, currentTab });

                    // Reflect persisted my-clients filter on the toggle button if present
                    const btn = document.getElementById('myClientsToggle');
                    if (btn) {
                        btn.title = myClientsOnly ? 'Showing only my clients' : 'Show only my clients';
                        btn.innerHTML = myClientsOnly ? '<i class="fas fa-filter"></i>' : '<i class="fas fa-user-check"></i>';
                    }
                }
            } catch (error) {
                console.error('Error loading settings:', error);
                persistLog('settings.load.error', { error: String(error) });
            }
        }

        function saveSettingsToStorage() {
            try {
                const settings = {
                    autoExportEnabled,
                    autoExportDays,
                    autoExportTime,
                    clientsTabEnabled,
                    myClientsOnly,
                    currentTab
                };
                localStorage.setItem('legalTasksSettings', JSON.stringify(settings));
                persistLog('settings.save', settings);
            } catch (error) {
                console.error('Error saving settings:', error);
                persistLog('settings.save.error', { error: String(error) });
            }
        }

        function updateSettingsDisplay() {
            document.getElementById('autoExportEnabled').checked = autoExportEnabled;
            document.getElementById('exportTime').value = autoExportTime;
            document.getElementById('clientsTabEnabled').checked = clientsTabEnabled;
            
            // Update day checkboxes
            for (let i = 0; i <= 6; i++) {
                const checkbox = document.getElementById(`exportDay${i}`);
                if (checkbox) {
                    checkbox.checked = autoExportDays.includes(i);
                }
            }
            
            // Update export day and time group visibility
            const exportDayGroup = document.getElementById('exportDayGroup');
            const exportTimeGroup = document.getElementById('exportTimeGroup');
            exportDayGroup.style.display = autoExportEnabled ? 'block' : 'none';
            exportTimeGroup.style.display = autoExportEnabled ? 'block' : 'none';
            
            // Update description
            updateExportDescription();
            
            // Update export statistics
            updateExportStatistics();

            // Show/hide Clients tab
            const clientsTab = document.querySelector(".tabs-container .tab[onclick=\"switchTab('clients')\"]");
            const myToggle = document.getElementById('myClientsToggle');
            if (clientsTab) clientsTab.style.display = clientsTabEnabled ? '' : 'none';
            if (!clientsTabEnabled && currentTab === 'clients') {
                // If disabled while on clients, switch back to pending
                currentTab = 'pending';
                document.querySelectorAll('.tab').forEach(t => t.classList.remove('active'));
                const pendingTab = document.querySelector(".tabs-container .tab[onclick=\"switchTab('pending')\"]");
                if (pendingTab) pendingTab.classList.add('active');
                if (myToggle) myToggle.style.display = 'none';
                filterTasks();
            }
        }

        function toggleClientsTabEnabled() {
            const checkbox = document.getElementById('clientsTabEnabled');
            clientsTabEnabled = !!(checkbox && checkbox.checked);
            saveSettingsToStorage();
            persistLog('settings.toggle.clientsTabEnabled', { clientsTabEnabled });
            updateSettingsDisplay();
        }

        function updateExportStatistics() {
            const lastExport = localStorage.getItem('lastExport');
            const lastExportType = localStorage.getItem('lastExportType');
            const lastExportElement = document.getElementById('lastExportDate');
            const nextExportElement = document.getElementById('nextExportDate');
            
            if (lastExport) {
                const typeText = lastExportType ? ` (${lastExportType})` : '';
                lastExportElement.textContent = formatDateTime(lastExport) + typeText;
            } else {
                lastExportElement.textContent = 'Never';
            }
            
            if (autoExportEnabled) {
                const nextExport = getNextExportDate();
                nextExportElement.textContent = nextExport.toLocaleDateString();
            } else {
                nextExportElement.textContent = 'Disabled';
            }
        }

        function updateExportDescription() {
            const descElement = document.getElementById('exportDescription');
            if (!autoExportEnabled || autoExportDays.length === 0) {
                descElement.textContent = 'Automatic export is disabled';
                return;
            }
            
            const dayNames = ['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'];
            const selectedDays = autoExportDays.map(day => dayNames[day]);
            
            let dayText = '';
            if (selectedDays.length === 7) {
                dayText = 'every day';
            } else if (selectedDays.length === 1) {
                dayText = `every ${selectedDays[0]}`;
            } else if (selectedDays.length === 2) {
                dayText = `every ${selectedDays.join(' and ')}`;
            } else {
                dayText = `every ${selectedDays.slice(0, -1).join(', ')} and ${selectedDays[selectedDays.length - 1]}`;
            }
            
            descElement.textContent = `Automatically export tasks as JSON file ${dayText} at ${autoExportTime}`;
        }

        function getNextExportDate() {
            if (!autoExportEnabled || autoExportDays.length === 0) {
                return null;
            }
            
            const now = new Date();
            const currentDay = now.getDay();
            const currentTime = now.getHours() * 60 + now.getMinutes();
            const [exportHours, exportMinutes] = autoExportTime.split(':').map(Number);
            const exportTimeMinutes = exportHours * 60 + exportMinutes;
            
            
            // Find the next export day
            let nextExportDay = null;
            let daysToAdd = 0;
            
            // Check if today is an export day and time hasn't passed (with 1 minute buffer)
            // Also check if we haven't already handled the export today
            const today_string = now.toISOString().split('T')[0];
            const lastExport = localStorage.getItem('lastAutoExport');
            const lastDismissal = localStorage.getItem('lastExportDismissal');
            const alreadyHandledToday = (lastExport && lastExport.startsWith(today_string)) || 
                                       (lastDismissal && lastDismissal === today_string);
            
            if (autoExportDays.includes(currentDay) && currentTime < (exportTimeMinutes + 1) && !alreadyHandledToday) {
                nextExportDay = currentDay;
                daysToAdd = 0;
            } else {
                // Find next export day
                for (let i = 1; i <= 7; i++) {
                    const checkDay = (currentDay + i) % 7;
                    if (autoExportDays.includes(checkDay)) {
                        nextExportDay = checkDay;
                        daysToAdd = i;
                        break;
                    }
                }
            }
            
            if (nextExportDay === null) {
                return null;
            }
            
            const nextExport = new Date(now);
            nextExport.setDate(now.getDate() + daysToAdd);
            nextExport.setHours(exportHours, exportMinutes, 0, 0);
            
            return nextExport;
        }

        function toggleAutoExport() {
            autoExportEnabled = document.getElementById('autoExportEnabled').checked;
            updateSettingsDisplay();
        }

        function updateExportSettings() {
            // Get selected days
            autoExportDays = [];
            for (let i = 0; i <= 6; i++) {
                const checkbox = document.getElementById(`exportDay${i}`);
                if (checkbox && checkbox.checked) {
                    autoExportDays.push(i);
                }
            }
            
            // Get time
            autoExportTime = document.getElementById('exportTime').value;
            
            updateSettingsDisplay();
        }

        function saveSettings() {
            saveSettingsToStorage();
            
            // Re-setup smart scheduling with new settings
            console.log('Re-setting up smart scheduling after settings change...');
            setupSmartExportScheduling();
            
            closeSettings();
            showNotification('Settings saved successfully!', 'success');
        }

        // Data persistence
        function saveTasks() {
            try {
                localStorage.setItem('legalTasks', JSON.stringify(tasks));
                localStorage.setItem('legalCustomers', JSON.stringify([...customers]));
                localStorage.setItem('legalClientsMeta', JSON.stringify(clientsMeta));
                persistLog('tasks.save', { tasksCount: tasks.length, customersCount: customers.size });
            } catch (error) {
                showNotification('Error saving tasks', 'error');
                console.error('Error saving tasks:', error);
                persistLog('tasks.save.error', { error: String(error) });
            }
        }

        function loadTasks() {
            try {
                const savedTasks = localStorage.getItem('legalTasks');
                const savedCustomers = localStorage.getItem('legalCustomers');
                
                let tasksMigrated = false;
                if (savedTasks) {
                    tasks = JSON.parse(savedTasks);
                    persistLog('tasks.load', { tasksCount: tasks.length });
                    
                    // Handle backward compatibility and update existing tasks with sub-tasks
                    tasks.forEach((task, index) => {
                        if (!task.subTasks) {
                            task.subTasks = parseSubTasks(task.description || '');
                        }
                    });
                    // Defer saving until after customers and clientsMeta are loaded
                    tasksMigrated = true;
                }
                
                if (savedCustomers) {
                    customers = new Set(JSON.parse(savedCustomers));
                    persistLog('customers.load', { customersCount: customers.size });
                }
                // Load client labels first (needed for migration)
                const savedLabels = localStorage.getItem('legalClientLabels');
                if (savedLabels) {
                    const parsed = JSON.parse(savedLabels);
                    // Handle backward compatibility: convert old string array to new object structure
                    if (Array.isArray(parsed) && parsed.length > 0 && typeof parsed[0] === 'string') {
                        // Old format: array of strings, convert to new format
                        clientLabels = parsed.map((name, index) => ({
                            id: `label_migrated_${Date.now()}_${index}`,
                            name: name,
                            phases: []
                        }));
                        saveClientLabels(); // Save in new format
                    } else {
                        clientLabels = parsed;
                    }
                } else {
                    // Start with empty labels - user creates all
                    clientLabels = [];
                    saveClientLabels();
                }
                persistLog('clientLabels.load', { count: clientLabels.length });
                
                // Load simple labels
                loadSimpleLabels();
                
                const savedClientsMeta = localStorage.getItem('legalClientsMeta');
                if (savedClientsMeta) {
                    clientsMeta = JSON.parse(savedClientsMeta);
                    // Migrate old labels format to new labelIds format
                    let needsSave = false;
                    Object.keys(clientsMeta).forEach(key => {
                        const meta = clientsMeta[key];
                        if (meta.labels && Array.isArray(meta.labels) && meta.labels.length > 0 && typeof meta.labels[0] === 'string') {
                            // Old format: labels array of strings, convert to labelIds
                            if (!meta.labelIds) {
                                meta.labelIds = [];
                            }
                            // Try to match old label strings to new label IDs
                            meta.labels.forEach(oldLabelName => {
                                const matchingLabel = clientLabels.find(l => l.name === oldLabelName);
                                if (matchingLabel && !meta.labelIds.includes(matchingLabel.id)) {
                                    meta.labelIds.push(matchingLabel.id);
                                }
                            });
                            delete meta.labels; // Remove old format
                            needsSave = true;
                        }
                    });
                    if (needsSave) {
                        saveClientsMeta(); // Save migrated data
                    }
                    persistLog('clientsMeta.load', clientsMeta);
                }
                
                // Now that all pieces are loaded, persist any migrations exactly once
                if (tasksMigrated) {
                    persistLog('tasks.migration.save', { tasksCount: tasks.length, customersCount: customers.size, hasClientsMeta: Object.keys(clientsMeta || {}).length > 0 });
                    saveTasks();
                }
                
                updateCustomerSuggestions();
            } catch (error) {
                showNotification('Error loading tasks', 'error');
                console.error('Error loading tasks:', error);
                persistLog('tasks.load.error', { error: String(error) });
            }
        }

        // Clients helpers and UI
        function getClientKey(name) {
            return name || '';
        }

        function getClientsArray() {
            const names = [...customers];
            const clients = names.map((name, idx) => {
                const key = getClientKey(name);
                const meta = clientsMeta[key] || {};
                const seed = Array.from(key).reduce((a, c) => (a + c.charCodeAt(0)) % 1000, 0);
                const palette = ['#6c5ce7','#e17055','#00b894','#0984e3','#fdcb6e','#e84393','#2d3436','#16a085'];
                const icons = ['user','user-tie','user-circle','user-astronaut','user-nurse','user-secret','user-shield','user'];
                const color = meta.color || palette[seed % palette.length];
                const icon = meta.icon || icons[seed % icons.length];
                const assigned = !!meta.assigned;
                const order = typeof meta.order === 'number' ? meta.order : idx;
                return { name, key, color, icon, assigned, order };
            });
            clients.sort((a, b) => a.order - b.order);
            return clients;
        }

        function saveClientsMeta() {
            try {
                localStorage.setItem('legalClientsMeta', JSON.stringify(clientsMeta));
                persistLog('clientsMeta.save', clientsMeta);
            } catch (e) {
                console.error('Error saving clients meta', e);
                persistLog('clientsMeta.save.error', { error: String(e) });
            }
        }

        function saveClientLabels() {
            try {
                localStorage.setItem('legalClientLabels', JSON.stringify(clientLabels));
                persistLog('clientLabels.save', { count: clientLabels.length });
            } catch (e) {
                console.error('Error saving client labels', e);
                persistLog('clientLabels.save.error', { error: String(e) });
            }
        }

        function renderClientLabels(clientKey) {
            const meta = clientsMeta[clientKey] || {};
            const labelIds = meta.labelIds || [];
            if (labelIds.length === 0) return '';
            
            // Separate labels and workflows
            const labels = [];
            const workflows = [];
            
            labelIds.forEach(id => {
                const simpleLabel = simpleLabels.find(l => l.id === id);
                if (simpleLabel) {
                    labels.push(simpleLabel);
                } else {
                    const workflowLabel = clientLabels.find(l => l.id === id);
                    if (workflowLabel) {
                        workflows.push(workflowLabel);
                    }
                }
            });
            
            if (labels.length === 0 && workflows.length === 0) return '';
            
            return `
                <div style="display: flex; flex-wrap: wrap; gap: 6px; margin-top: 8px;">
                    ${labels.map(label => `
                        <span style="display: inline-flex; align-items: center; padding: 4px 10px; background: var(--secondary-color); color: var(--white); border-radius: 12px; font-size: 0.8rem; font-weight: 500;">
                            <i class="fas fa-tag" style="font-size: 0.7rem; margin-right: 4px;"></i>
                            ${escapeHtml(label.name)}
                        </span>
                    `).join('')}
                    ${workflows.map(workflow => `
                        <span style="display: inline-flex; align-items: center; padding: 4px 10px; background: #764ba2; color: var(--white); border-radius: 12px; font-size: 0.8rem; font-weight: 500;">
                            <i class="fas fa-project-diagram" style="font-size: 0.7rem; margin-right: 4px;"></i>
                            ${escapeHtml(workflow.name)}
                        </span>
                    `).join('')}
                </div>
            `;
        }

        function renderClientTimeline(clientKey) {
            const meta = clientsMeta[clientKey] || {};
            const currentPhase = meta.currentPhase;
            if (!currentPhase) return '';
            
            const label = clientLabels.find(l => l.id === currentPhase.labelId);
            if (!label || !label.phases) return '';
            
            const findPhase = (phases, phaseId) => {
                for (const phase of phases) {
                    if (phase.id === phaseId) return phase;
                    if (phase.subPhases) {
                        const found = findPhase(phase.subPhases, phaseId);
                        if (found) return found;
                    }
                }
                return null;
            };
            const currentPhaseObj = findPhase(label.phases, currentPhase.phaseId);
            const currentPhaseTasks = currentPhaseObj && currentPhaseObj.tasks ? currentPhaseObj.tasks : [];
            
            const addedTasks = meta.addedTemplateTasks || [];
            const availableTasks = currentPhaseTasks.filter(task => !addedTasks.includes(task.trim()));
            
            const tasksToggleId = `tasks_${clientKey}_${currentPhase.phaseId}`;
            const tasksVisible = meta.tasksVisible !== undefined ? meta.tasksVisible : true;
            
            const parentPhases = label.phases.slice();
            const subPhaseGroups = new Map();
            parentPhases.forEach(parent => {
                if (parent.subPhases && parent.subPhases.length > 0) {
                    subPhaseGroups.set(parent.id, parent.subPhases);
                }
            });
            
            let currentParentIndex = -1;
            let currentSubIndex = -1;
            parentPhases.forEach((parent, idx) => {
                if (parent.id === currentPhase.phaseId) {
                    currentParentIndex = idx;
                    currentSubIndex = -1;
                } else if (parent.subPhases) {
                    const subIdx = parent.subPhases.findIndex(sp => sp.id === currentPhase.phaseId);
                    if (subIdx !== -1) {
                        currentParentIndex = idx;
                        currentSubIndex = subIdx;
                    }
                }
            });
            if (currentParentIndex === -1) return '';
            
            const timelineMarkup = parentPhases.map((parentPhase, parentIndex) => {
                const subPhases = subPhaseGroups.get(parentPhase.id) || [];
                const isPastParent = parentIndex < currentParentIndex;
                const isCurrentParent = parentIndex === currentParentIndex;
                const parentState = isPastParent ? 'is-past' : isCurrentParent ? 'is-current' : 'is-future';
                
                const parentPhaseMarkup = `
                    <div class="timeline-phase ${parentState}" onclick="event.stopPropagation(); changeClientPhase('${clientKey}', '${currentPhase.labelId}', '${parentPhase.id}')">
                        ${escapeHtml(parentPhase.name)}
                    </div>
                `;
                
                let subPhaseTrack = '';
                if (subPhases.length > 0) {
                    subPhaseTrack = `
                        <div class="timeline-track">
                            ${subPhases.map((subPhase, subIndex) => {
                                let subState = 'is-future';
                                if (parentIndex < currentParentIndex) {
                                    subState = 'is-past';
                                } else if (parentIndex > currentParentIndex) {
                                    subState = 'is-future';
                                } else {
                                    if (currentSubIndex === -1) {
                                        subState = 'is-future';
                                    } else if (subIndex < currentSubIndex) {
                                        subState = 'is-past';
                                    } else if (subIndex === currentSubIndex) {
                                        subState = 'is-current';
                                    } else {
                                        subState = 'is-future';
                                    }
                                }
                                
                                return `
                                    <div class="timeline-subphase ${subState}" onclick="event.stopPropagation(); changeClientPhase('${clientKey}', '${currentPhase.labelId}', '${subPhase.id}')">
                                        ${escapeHtml(subPhase.name)}
                                    </div>
                                    ${subIndex < subPhases.length - 1 ? `<div class="timeline-track-connector ${subState === 'is-past' ? 'is-past' : 'is-future'}"></div>` : ''}
                                `;
                            }).join('')}
                        </div>
                    `;
                }
                
                const column = `
                    <div class="timeline-column">
                        ${parentPhaseMarkup}
                        ${subPhaseTrack}
                    </div>
                `;
                
                const connectorClass = parentIndex < parentPhases.length - 1
                    ? (parentIndex < currentParentIndex ? 'is-past' : 'is-future')
                    : '';
                const connector = parentIndex < parentPhases.length - 1 ? `<div class="timeline-column-connector ${connectorClass}"></div>` : '';
                
                return column + connector;
            }).join('');
            
            return `
                <div class="client-tasks-section" style="margin-bottom: 15px;">
                    <div class="client-timeline">
                        ${timelineMarkup}
                    </div>
                    ${availableTasks.length > 0 ? `
                        <div style="margin-top: 8px;">
                            <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px;">
                                <button onclick="event.stopPropagation(); toggleTasksVisibility('${clientKey}')" style="
                                    background: none;
                                    border: none;
                                    color: var(--light-text);
                                    cursor: pointer;
                                    padding: 4px;
                                    font-size: 0.85rem;
                                " title="${tasksVisible ? 'Hide' : 'Show'} template tasks">
                                    <i class="fas fa-${tasksVisible ? 'minus' : 'plus'}" style="margin-right: 4px;"></i>
                                    ${tasksVisible ? 'Hide' : 'Show'} Template Tasks (${availableTasks.length})
                                </button>
                            </div>
                            <div id="${tasksToggleId}" style="display: ${tasksVisible ? 'block' : 'none'}; margin-left: 12px;">
                                ${availableTasks.map((taskTitle, taskIndex) => `
                                    <div style="display: flex; align-items: center; gap: 8px; margin-bottom: 6px; padding: 6px; border-radius: 4px; transition: background 0.2s;" 
                                         onmouseenter="this.style.background='rgba(52, 152, 219, 0.1)'" 
                                         onmouseleave="this.style.background='transparent'">
                                        <span style="flex: 1; font-size: 0.85rem; color: var(--dark-text);">${escapeHtml(taskTitle)}</span>
                                        <button onclick="event.stopPropagation(); createTaskFromTemplate('${clientKey}', '${escapeHtml(taskTitle).replace(/'/g, "\\'")}')" 
                                                style="background: var(--secondary-color); color: white; border: none; border-radius: 4px; padding: 4px 8px; cursor: pointer; font-size: 0.75rem;" 
                                                title="Add this task">
                                            <i class="fas fa-plus"></i>
                                        </button>
                                    </div>
                                `).join('')}
                            </div>
                        </div>
                    ` : ''}
                </div>
            `;
        }
        
        function changeClientPhase(clientKey, labelId, phaseId) {
            const label = clientLabels.find(l => l.id === labelId);
            if (!label) return;
            
            const findPhase = (phases, id, path = []) => {
                for (const phase of phases) {
                    const currentPath = [...path, phase.name];
                    if (phase.id === id) {
                        return { phase, path: currentPath };
                    }
                    if (phase.subPhases) {
                        const found = findPhase(phase.subPhases, id, currentPath);
                        if (found) return found;
                    }
                }
                return null;
            };
            
            const result = findPhase(label.phases, phaseId);
            if (!result) return;
            
            clientsMeta[clientKey] = clientsMeta[clientKey] || {};
            // Preserve expanded state
            const wasExpanded = clientsMeta[clientKey].expanded || false;
            clientsMeta[clientKey].currentPhase = {
                labelId: labelId,
                phaseId: phaseId,
                phasePath: result.path
            };
            clientsMeta[clientKey].expanded = wasExpanded; // Keep expanded state
            saveClientsMeta();
            
            if (currentTab === 'clients') renderClients();
            showNotification(`Moved to phase "${result.phase.name}"`, 'success');
        }
        
        function toggleTasksVisibility(clientKey) {
            clientsMeta[clientKey] = clientsMeta[clientKey] || {};
            // Preserve expanded state
            const wasExpanded = clientsMeta[clientKey].expanded || false;
            clientsMeta[clientKey].tasksVisible = !clientsMeta[clientKey].tasksVisible;
            clientsMeta[clientKey].expanded = wasExpanded; // Keep expanded state
            saveClientsMeta();
            if (currentTab === 'clients') renderClients();
        }
        
        function createTaskFromTemplate(clientKey, taskTitle) {
            const client = getClientsArray().find(c => c.key === clientKey);
            if (!client) return;
            
            // Track that this template task was added
            clientsMeta[clientKey] = clientsMeta[clientKey] || {};
            if (!clientsMeta[clientKey].addedTemplateTasks) {
                clientsMeta[clientKey].addedTemplateTasks = [];
            }
            clientsMeta[clientKey].addedTemplateTasks.push(taskTitle.trim());
            // Preserve expanded state
            const wasExpanded = clientsMeta[clientKey].expanded || false;
            clientsMeta[clientKey].expanded = wasExpanded;
            
            const task = {
                id: Date.now().toString() + '_' + Math.random().toString(36).substr(2, 9),
                title: taskTitle.trim(),
                description: '',
                customer: clientKey,
                reminderDateTime: '',
                completed: false,
                createdAt: new Date().toISOString(),
                completedAt: null,
                subTasks: []
            };
            
            tasks.push(task);
            saveTasks();
            saveClientsMeta();
            updateStats();
            updateCustomerList();
            updateCustomerSuggestions();
            filterTasks();
            
            showNotification(`Task "${taskTitle}" created`, 'success');
            
            if (currentTab === 'clients') {
                renderClients();
            }
        }


        function renderClients() {
            const taskList = document.getElementById('taskList');
            if (sortableInstance) { sortableInstance.destroy(); sortableInstance = null; }
            if (clientsSortableInstance) { clientsSortableInstance.destroy(); clientsSortableInstance = null; }

            const allClients = getClientsArray();
            // Merge meta flags
            allClients.forEach(c => {
                const meta = clientsMeta[c.key] || {};
                c.assigned = !!meta.assigned;
                c.archived = !!meta.archived;
            });
            // When filtering to "my clients only", exclude archived; otherwise include all
            const filtered = myClientsOnly ? allClients.filter(c => c.assigned && !c.archived) : allClients;

            const clientsBadge = document.getElementById('clientsBadge');
            if (clientsBadge) clientsBadge.textContent = filtered.length;

            // Ensure toggle button reflects current state when entering Clients tab
            const btn = document.getElementById('myClientsToggle');
            if (btn) {
                btn.title = myClientsOnly ? 'Showing only my clients' : 'Show only my clients';
                btn.innerHTML = myClientsOnly ? '<i class="fas fa-filter"></i>' : '<i class="fas fa-user-check"></i>';
            }

            if (filtered.length === 0) {
                taskList.innerHTML = `
                    <div class="empty-state">
                        <i class="fas fa-users"></i>
                        <h3>No ${myClientsOnly ? 'assigned' : ''} clients</h3>
                        <p>${allClients.length === 0 ? 'Add your first task to get started.' : 'Assign clients to yourself or clear filters.'}</p>
                    </div>
                `;
                return;
            }

            // Order: active (not archived) first, then archived
            const activeClients = filtered.filter(c => !c.archived);
            const archivedClients = filtered.filter(c => c.archived);
            const ordered = activeClients.concat(archivedClients);

            taskList.innerHTML = ordered.map(c => {
                // Get tasks for this client
                const clientTasks = tasks.filter(t => t.customer === c.name);
                const pendingTasks = clientTasks.filter(t => !t.completed).sort((a, b) => new Date(b.createdAt) - new Date(a.createdAt));
                const completedTasks = clientTasks.filter(t => t.completed).sort((a, b) => new Date(b.completedAt) - new Date(a.completedAt));
                const totalTasks = clientTasks.length;
                
                // Generate task list HTML
                const timelineHTML = renderClientTimeline(c.key);
                const meta = clientsMeta[c.key] || {};
                const isExpanded = meta.expanded || false;
                const tasksHTML = (totalTasks > 0 || timelineHTML) ? `
                    <div class="client-tasks-list" style="display: ${isExpanded ? 'block' : 'none'};">
                        <div class="client-tasks-inner">
                            ${timelineHTML}
                            ${pendingTasks.length > 0 ? `
                                <div class="client-tasks-section">
                                    <div style="font-weight: 600; color: var(--secondary-color); margin-bottom: 10px; font-size: 0.9rem;">
                                        <i class="fas fa-clock"></i> Open Tasks (${pendingTasks.length})
                                    </div>
                                    ${pendingTasks.map(t => `
                                        <div class="client-task-item" onclick="event.stopPropagation(); navigateToTask('${t.id}', false)" title="Click to view in Pending tab">
                                            <i class="fas fa-circle" style="font-size: 6px; color: var(--secondary-color); margin-right: 8px;"></i>
                                            <span>${escapeHtml(t.title)}</span>
                                            ${t.reminderDateTime ? `<i class="fas fa-bell" style="margin-left: 8px; color: var(--warning-color); font-size: 0.85rem;"></i>` : ''}
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                            ${completedTasks.length > 0 ? `
                                <div class="client-tasks-section">
                                    <div style="font-weight: 600; color: var(--success-color); margin-bottom: 10px; font-size: 0.9rem;">
                                        <i class="fas fa-check-circle"></i> Completed Tasks (${completedTasks.length})
                                    </div>
                                    ${completedTasks.map(t => `
                                        <div class="client-task-item completed" onclick="event.stopPropagation(); navigateToTask('${t.id}', true)" title="Click to view in Completed tab">
                                            <i class="fas fa-check" style="font-size: 10px; color: var(--success-color); margin-right: 8px;"></i>
                                            <span style="text-decoration: line-through; opacity: 0.7;">${escapeHtml(t.title)}</span>
                                        </div>
                                    `).join('')}
                                </div>
                            ` : ''}
                        </div>
                    </div>
                ` : '';
                
                return `
                <div class="task-item client-item${c.archived ? ' archived' : ''}" data-client-key="${escapeHtml(c.key)}" onclick="toggleClientExpansion('${c.key.replace(/'/g, "&#39;")}')" style="cursor: pointer;">
                    <div class="task-controls">
                        ${(totalTasks > 0 || timelineHTML) ? `
                            <button class="task-control-btn client-expand-btn" onclick="event.stopPropagation(); toggleClientExpansion('${c.key.replace(/'/g, "&#39;")}')" title="Expand/Collapse">
                                <i class="fas fa-chevron-down client-expand-icon" style="transition: transform 0.3s ease;"></i>
                            </button>
                        ` : ''}
                        <button class="task-control-btn" onclick="event.stopPropagation(); cycleClientState('${c.key.replace(/'/g, "&#39;")}')" title="${(!c.assigned && !c.archived) ? 'Assign to me' : (c.assigned && !c.archived) ? 'Archive client' : (c.assigned && c.archived) ? 'Unassign from me' : 'Unarchive client'}">
                            <i class="fas ${(!c.assigned && !c.archived) ? 'fa-user-check' : (c.assigned && !c.archived) ? 'fa-box-archive' : (c.assigned && c.archived) ? 'fa-user-minus' : 'fa-box-open'}"></i>
                        </button>
                        <button class="task-control-btn" onclick="event.stopPropagation(); moveClientToTop('${c.key.replace(/'/g, "&#39;")}')" title="Move to Top">
                            <i class="fas fa-arrow-up"></i>
                        </button>
                        <button class="task-control-btn" onclick="event.stopPropagation(); quickAddLabel('${c.key.replace(/'/g, "&#39;")}')" title="Add Label">
                            <i class="fas fa-tag"></i>
                        </button>
                        <button class="task-control-btn" onclick="event.stopPropagation(); showClientWorkflows('${c.key.replace(/'/g, "&#39;")}')" title="Manage Workflows">
                            <i class="fas fa-project-diagram"></i>
                        </button>
                        <button class="task-control-btn" onclick="event.stopPropagation(); showClientInfo('${c.key.replace(/'/g, "&#39;")}')" title="Client Information">
                            <i class="fas fa-info-circle"></i>
                        </button>
                        <button class="task-control-btn" onclick="event.stopPropagation(); editClient('${c.key.replace(/'/g, "&#39;")}')" title="Edit Client">
                            <i class="fas fa-edit"></i>
                        </button>
                        <button class="task-control-btn delete" onclick="event.stopPropagation(); deleteClient('${c.key.replace(/'/g, "&#39;")}')" title="Delete Client">
                            <i class="fas fa-trash"></i>
                        </button>
                    </div>
                    <div class="task-header client-header" style="align-items: center; gap: 12px;">
                        <div style="display:flex; align-items:center; gap:12px; flex: 1;">
                            <div style="position:relative; width:36px; height:36px; border-radius:50%; background:${c.color}; color:#fff; display:flex; align-items:center; justify-content:center;">
                                <i class="fas fa-${c.icon}"></i>
                                ${c.assigned ? '<span style="position:absolute; right:-4px; bottom:-4px; background:#2ecc71; color:#fff; border-radius:50%; width:16px; height:16px; display:flex; align-items:center; justify-content:center; box-shadow: 0 0 0 2px #fff;"><i class="fas fa-check" style="font-size:10px;"></i></span>' : ''}
                            </div>
                            <div class="task-title" style="flex: 1;">
                                ${escapeHtml(c.name)}
                                ${clientsMeta[c.key] && clientsMeta[c.key].notes ? `<div style="color: var(--light-text); font-size: 0.9rem; margin-top: 5px; line-height: 1.4; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; font-weight: 400;">${escapeHtml(clientsMeta[c.key].notes)}</div>` : ''}
                                ${renderClientLabels(c.key)}
                                ${c.archived ? `<span class=\"client-archived-badge\"><i class=\"fas fa-box-archive\"></i> Archived</span>` : ''}
                            </div>
                        </div>
                    </div>
                    ${tasksHTML}
                </div>
                `;
            }).join('');

            initializeClientsSortable();
        }

        function initializeClientsSortable() {
            const list = document.getElementById('taskList');
            clientsSortableInstance = new Sortable(list, {
                ghostClass: 'sortable-ghost',
                chosenClass: 'sortable-chosen',
                dragClass: 'sortable-drag',
                animation: 150,
                easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
                filter: '.btn, .btn *, .task-control-btn, .task-control-btn *, .client-tasks-list, .client-tasks-list *',
                preventOnFilter: false,
                onEnd: function() {
                    const items = list.querySelectorAll('[data-client-key]');
                    items.forEach((el, idx) => {
                        const key = el.getAttribute('data-client-key');
                        clientsMeta[key] = clientsMeta[key] || {};
                        clientsMeta[key].order = idx;
                    });
                    saveClientsMeta();
                    showNotification('Clients order updated', 'success');
                }
            });
        }

        function toggleClientExpansion(clientKey) {
            const clientItem = document.querySelector(`[data-client-key="${clientKey}"]`);
            console.log('[client-expand] toggleClientExpansion called', { clientKey, found: !!clientItem });
            
            if (!clientItem) {
                console.warn('[client-expand] clientItem not found for key:', clientKey);
                return;
            }
            
            const tasksList = clientItem.querySelector('.client-tasks-list');
            const expandIcon = clientItem.querySelector('.client-expand-icon');
            
            console.log('[client-expand] elements found', { 
                tasksList: !!tasksList, 
                expandIcon: !!expandIcon 
            });
            
            if (!tasksList) {
                console.warn('[client-expand] tasksList not found');
                return;
            }
            
            // Check current state based on display property
            const isExpanded = tasksList.style.display !== 'none' && tasksList.style.display !== '';
            // Save expanded state to meta
            clientsMeta[clientKey] = clientsMeta[clientKey] || {};
            clientsMeta[clientKey].expanded = !isExpanded;
            saveClientsMeta();
            const currentDisplay = tasksList.style.display;
            const currentMaxHeight = tasksList.style.maxHeight;
            const currentOpacity = tasksList.style.opacity;
            const scrollHeight = tasksList.scrollHeight;
            
            console.log('[client-expand] current state', { 
                isExpanded, 
                currentDisplay, 
                currentMaxHeight, 
                currentOpacity, 
                scrollHeight,
                time: performance.now().toFixed(2) 
            });
            
            if (isExpanded) {
                // Collapse with animation
                console.log('[client-expand] COLLAPSING...');
                
                // First, set current height explicitly
                const startHeight = tasksList.scrollHeight;
                tasksList.style.maxHeight = startHeight + 'px';
                tasksList.style.opacity = '1';
                
                console.log('[client-expand] collapse - set initial height', { startHeight });
                
                // Force reflow to ensure the browser processes the height change
                tasksList.offsetHeight;
                
                // Then animate to 0
                requestAnimationFrame(() => {
                    console.log('[client-expand] collapse - animating to 0');
                    tasksList.style.maxHeight = '0';
                    tasksList.style.opacity = '0';
                });
                
                const onCollapseEnd = (e) => {
                    if (e.propertyName !== 'max-height') return;
                    tasksList.removeEventListener('transitionend', onCollapseEnd);
                    console.log('[client-expand] collapse - transition ended, hiding element');
                    tasksList.style.display = 'none';
                    // Keep maxHeight and opacity at 0 for next expansion
                };
                
                tasksList.addEventListener('transitionend', onCollapseEnd);
                
                // Rotate icon back
                if (expandIcon) {
                    expandIcon.style.transform = 'rotate(0deg)';
                }
            } else {
                // Expand with animation
                console.log('[client-expand] EXPANDING...');
                
                // Show the element first
                tasksList.style.display = 'block';
                
                // Reset to collapsed state
                tasksList.style.maxHeight = '0';
                tasksList.style.opacity = '0';
                
                // Force reflow to ensure display:block is processed
                tasksList.offsetHeight;
                
                // Get the target height after element is visible
                const targetHeight = tasksList.scrollHeight;
                console.log('[client-expand] expand - target height', { targetHeight });
                
                // Animate to full height
                requestAnimationFrame(() => {
                    console.log('[client-expand] expand - animating to', targetHeight);
                    tasksList.style.maxHeight = targetHeight + 'px';
                    tasksList.style.opacity = '1';
                });
                
                const onExpandEnd = (e) => {
                    if (e.propertyName !== 'max-height') return;
                    tasksList.removeEventListener('transitionend', onExpandEnd);
                    console.log('[client-expand] expand - transition ended, removing maxHeight constraint');
                    // Remove maxHeight constraint so content can grow if needed
                    tasksList.style.maxHeight = 'none';
                };
                
                tasksList.addEventListener('transitionend', onExpandEnd);
                
                // Rotate icon down
                if (expandIcon) {
                    expandIcon.style.transform = 'rotate(180deg)';
                }
            }
            
            console.log('[client-expand] toggleClientExpansion completed');
        }

        function navigateToTask(taskId, isCompleted) {
            // Switch to the appropriate tab
            const targetTab = isCompleted ? 'completed' : 'pending';
            switchTab(targetTab);
            
            // Wait for the tab to render, then scroll to and highlight the task
            setTimeout(() => {
                const taskElement = document.querySelector(`[data-task-id="${taskId}"]`);
                if (taskElement) {
                    taskElement.scrollIntoView({ behavior: 'smooth', block: 'center' });
                    
                    // Add a highlight effect
                    taskElement.style.transition = 'all 0.3s ease';
                    taskElement.style.background = 'linear-gradient(135deg, rgba(52, 152, 219, 0.1), rgba(155, 89, 182, 0.1))';
                    taskElement.style.transform = 'scale(1.02)';
                    
                    setTimeout(() => {
                        taskElement.style.background = '';
                        taskElement.style.transform = '';
                    }, 1500);
                }
            }, 100);
        }

        function toggleAssignClient(key) {
            clientsMeta[key] = clientsMeta[key] || {};
            clientsMeta[key].assigned = !clientsMeta[key].assigned;
            // Reset archived if assigning
            if (clientsMeta[key].assigned) clientsMeta[key].archived = false;
            saveClientsMeta();
            persistLog('clientsMeta.toggleAssigned', { key, assigned: clientsMeta[key].assigned });
            if (currentTab === 'clients') renderClients();
        }

        function cycleClientState(key) {
            clientsMeta[key] = clientsMeta[key] || {};
            const meta = clientsMeta[key];
            const prev = { assigned: !!meta.assigned, archived: !!meta.archived };
            // Sequence: not assigned && not archived -> assigned -> archived -> unassigned (still archived) -> unarchived (back to not assigned)
            if (!meta.assigned && !meta.archived) {
                // Assign to me
                meta.assigned = true;
                meta.archived = false;
            } else if (meta.assigned && !meta.archived) {
                // Archive (still assigned)
                meta.archived = true;
            } else if (meta.assigned && meta.archived) {
                // Unassign from me (remain archived)
                meta.assigned = false;
            } else if (!meta.assigned && meta.archived) {
                // Unarchive (becomes visible, still unassigned)
                meta.archived = false;
            }
            saveClientsMeta();
            persistLog('clientsMeta.cycleState', { key, prev, next: { assigned: meta.assigned, archived: meta.archived } });
            if (currentTab === 'clients') renderClients();
        }

        function toggleMyClientsOnly() {
            myClientsOnly = !myClientsOnly;
            const btn = document.getElementById('myClientsToggle');
            if (btn) {
                btn.title = myClientsOnly ? 'Showing only my clients' : 'Show only my clients';
                btn.innerHTML = myClientsOnly ? '<i class="fas fa-filter"></i>' : '<i class="fas fa-user-check"></i>';
            }
            // Persist this preference with the other settings
            saveSettingsToStorage();
            persistLog('settings.toggle.myClientsOnly', { myClientsOnly });
            if (currentTab === 'clients') renderClients();
        }

        // Utility functions
        function formatDateTime(dateString) {
            const date = new Date(dateString);
            return date.toLocaleDateString() + ' ' + date.toLocaleTimeString([], {hour: '2-digit', minute:'2-digit'});
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        // Keyboard shortcuts
        document.addEventListener('keydown', function(e) {
            // Close modal with Escape key
            if (e.key === 'Escape') {
                closeTaskInfo();
                closeEditTask();
                closeSettings();
                closePrivacyInfo();
                return;
            }
            
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'Enter':
                        e.preventDefault();
                        addTask();
                        break;
                    case 'f':
                        e.preventDefault();
                        document.getElementById('searchTasks').focus();
                        break;
                }
            }
        });
    </script>
</body>
</html>
